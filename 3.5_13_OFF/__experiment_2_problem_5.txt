[{"attempt": "0_0", "status": true, "solutions": "None"}, {"attempt": "1_1", "status": true, "solutions": "None"}, {"attempt": "1_2", "status": true, "solutions": "None"}, {"attempt": "2_1", "status": true, "solutions": "Solution(innocent=[True, True, True, False, True, False], _checker='')"}]

None
___________
% Statements from each suspect
array[1..6] of var bool: ARTIE;
array[1..6] of var bool: BILL;
array[1..6] of var bool: CRACKITT;
array[1..6] of var bool: DODGY;
array[1..6] of var bool: EDGY;
array[1..6] of var bool: FINGERS;

% At least four suspects are innocent
constraint sum(ARTIE) >= 4 /\ sum(BILL) >= 4 /\ sum(CRACKITT) >= 4 /\
  sum(DODGY) >= 4 /\ sum(EDGY) >= 4 /\ sum(FINGERS) >= 4;

% Innocent suspects tell the truth, guilty suspect(s) lie
constraint forall(i in 1..6) (
  (ARTIE[i] == false \/ i == 1) /\
  (BILL[i] == false \/ i == 2) /\
  (CRACKITT[i] == false \/ i == 3) /\
  (DODGY[i] == false \/ i == 4) /\
  (EDGY[i] == false \/ i == 5) /\
  (FINGERS[i] == false \/ i == 6)
);

% Relations between suspects' statements
constraint BILL[3] == not CRACKITT[3]; % Crackitt's statement contradicts Bill's
constraint DODGY[3] -> (CRACKITT[3] == true -> BILL[3] == true);
  % Dodgy's statement implies that if Crackitt did it, Bill did it with him
constraint EDGY[3] -> (sum([ARTIE[3], BILL[3], CRACKITT[3], DODGY[3], EDGY[3], FINGERS[3]]) >= 2);
  % Edgy's statement suggests the crime was done by multiple people
constraint FINGERS[3] -> (ARTIE[3] == true /\ DODGY[3] == true);
  % Fingers' statement implies Artie and Dodgy are guilty together

solve satisfy;

output["ARTIE: " ++ show(ARTIE[3]) ++ "\n"];
output["BILL: " ++ show(BILL[3]) ++ "\n"];
output["CRACKITT: " ++ show(CRACKITT[3]) ++ "\n"];
output["DODGY: " ++ show(DODGY[3]) ++ "\n"];
output["EDGY: " ++ show(EDGY[3]) ++ "\n"];
output["FINGERS: " ++ show(FINGERS[3]) ++ "\n"];
___________
% Number of suspects
n = 6; 

% Potential guilt assignment for each suspect (0 = innocent, 1 = guilty)
guilt = array1d(1..n, [0, 0, 0, 0, 0, 0]);

% Statements from each suspect
% ARTIE: "It wasn't me."
% BILL: "Crackitt was in it up to his neck."
% CRACKITT: "No I wasn't."
% DODGY: "If Crackitt did it, Bill did it with him."
% EDGY: "Nobody did it alone."
% FINGERS: "That’s right: it was Artie and Dodgy together."
% The guilty suspect(s) lie, innocent tell the truth
% For each suspect, their statement is true if they are innocent
% and it is false if they are guilty
% (1 = ARTIE, 2 = BILL, 3 = CRACKITT, 4 = DODGY, 5 = EDGY, 6 = FINGERS)
% Note: This data file will be used to check consistency of the solution
% with the given statements, the actual solution will be computed using
% the MiniZinc model
truths = array2d(1..n, 1..6, [1, 0, 1, 0, 0, 1,
                               1, 0, 1, 0, 0, 1,
                               1, 0, 1, 0, 0, 1,
                               1, 0, 1, 0, 0, 1,
                               1, 0, 1, 0, 0, 1,
                               1, 0, 1, 0, 0, 1]);
==============================None
___________
int: ARTIE = 1; % ARTIE: "It wasn't me."
int: BILL = 1; % BILL: "Crackitt was in it up to his neck."
int: CRACKITT = 1; % CRACKITT: "No I wasn't."
int: DODGY = 1; % DODGY: "If Crackitt did it, Bill did it with him."
int: EDGY = 1; % EDGY: "Nobody did it alone."
int: FINGERS = 1; % FINGERS: "That's right: it was Artie and Dodgy together."

% Variables to represent innocence (0) or guilt (1) of suspects
var 0..1: guiltiness_ARTIE; 
var 0..1: guiltiness_BILL;
var 0..1: guiltiness_CRACKITT;
var 0..1: guiltiness_DODGY;
var 0..1: guiltiness_EDGY;
var 0..1: guiltiness_FINGERS;

array[1..6] of var 0..5: guiltyCount; % To count the number of guilty suspects

% Constraint 1: Getaway car could only hold 2 people
constraint guiltyCount[1] + guiltyCount[2] + guiltyCount[3] + guiltyCount[4] + guiltyCount[5] + guiltyCount[6] == 2;

% Constraint 2: Innocent suspects tell the truth, guilty suspect(s) lie
constraint (guiltiness_ARTIE = 0 /\ ARTIE = 0) \/ (guiltiness_ARTIE = 1 /\ ARTIE = 1);
constraint (guiltiness_BILL = 0 /\ BILL = 0) \/ (guiltiness_BILL = 1 /\ BILL = 1);
constraint (guiltiness_CRACKITT = 0 /\ CRACKITT = 0) \/ (guiltiness_CRACKITT = 1 /\ CRACKITT = 1);
constraint (guiltiness_DODGY = 0 /\ DODGY = 0) \/ (guiltiness_DODGY = 1 /\ DODGY = 1);
constraint (guiltiness_EDGY = 0 /\ EDGY = 0) \/ (guiltiness_EDGY = 1 /\ EDGY = 1);
constraint (guiltiness_FINGERS = 0 /\ FINGERS = 0) \/ (guiltiness_FINGERS = 1 /\ FINGERS = 1);

% Constraint 3: If Crackitt did it, Bill did it with him
constraint (CRACKITT = 1 -> BILL = 1) /\ (BILL = 1 -> CRACKITT = 1);

% Constraint 4: Nobody did it alone (i.e., at least 2 people are guilty)
constraint guiltyCount[1] + guiltyCount[2] + guiltyCount[3] + guiltyCount[4] + guiltyCount[5] + guiltyCount[6] >= 2;

% Constraint 5: Deductions based on the suspects' statements
constraint (ARTIE = 1 -> guiltyCount[1] = 1) /\ (ARTIE = 0 -> guiltyCount[1] = 0);
constraint (BILL = 1 -> guiltyCount[2] = 1) /\ (BILL = 0 -> guiltyCount[2] = 0);
constraint (CRACKITT = 1 -> guiltyCount[3] = 1) /\ (CRACKITT = 0 -> guiltyCount[3] = 0);
constraint (DODGY = 1 -> guiltyCount[4] = 1) /\ (DODGY = 0 -> guiltyCount[4] = 0);
constraint (EDGY = 1 -> guiltyCount[5] = 1) /\ (EDGY = 0 -> guiltyCount[5] = 0);
constraint (FINGERS = 1 -> guiltyCount[6] = 1) /\ (FINGERS = 0 -> guiltyCount[6] = 0);

% Constraint 6: There is only one guilty suspect
constraint sum(guiltyCount) == 1;

solve satisfy;

output [
    "ARTIE is guilty: ", show(guiltyCount[1]), "\n",
    "BILL is guilty: ", show(guiltyCount[2]), "\n",
    "CRACKITT is guilty: ", show(guiltyCount[3]), "\n",
    "DODGY is guilty: ", show(guiltyCount[4]), "\n",
    "EDGY is guilty: ", show(guiltyCount[5]), "\n",
    "FINGERS is guilty: ", show(guiltyCount[6]), "\n"
];
___________
ARTIE = 1;
BILL = 1;
CRACKITT = 1;
DODGY = 1;
EDGY = 1;
FINGERS = 1;
==============================None
___________
% Declarations
var 0..1: ARTIE; % 0 - innocent, 1 - guilty (from dzn)
var 0..1: BILL; % 0 - innocent, 1 - guilty (from dzn)
var 0..1: CRACKITT; % 0 - innocent, 1 - guilty (from dzn)
var 0..1: DODGY; % 0 - innocent, 1 - guilty (from dzn)
var 0..1: EDGY; % 0 - innocent, 1 - guilty (from dzn)
var 0..1: FINGERS; % 0 - innocent, 1 - guilty (from dzn)

% Constraints based on the suspects' statements
constraint ARTIE = 1 \/ (ARTIE = 0 /\ BILL = 0 /\ CRACKITT = 0 /\ DODGY = 0 /\ EDGY = 0 /\ FINGERS = 0);
constraint BILL = 1 \/ (ARTIE = 0 /\ BILL = 1 /\ CRACKITT = 0 /\ DODGY = 0 /\ EDGY = 0 /\ FINGERS = 0);
constraint CRACKITT = 1 \/ (ARTIE = 0 /\ BILL = 0 /\ CRACKITT = 1 /\ DODGY = 0 /\ EDGY = 0 /\ FINGERS = 0);
constraint DODGY = 1 \/ (ARTIE = 0 /\ BILL = 0 /\ CRACKITT = 0 /\ DODGY = 1 /\ EDGY = 0 /\ FINGERS = 0);
constraint EDGY = 1 \/ (ARTIE = 0 /\ BILL = 0 /\ CRACKITT = 0 /\ DODGY = 0 /\ EDGY = 1 /\ FINGERS = 0);
constraint FINGERS = 1 \/ (ARTIE = 0 /\ BILL = 0 /\ CRACKITT = 0 /\ DODGY = 0 /\ EDGY = 0 /\ FINGERS = 1);

% Constraint: The getaway car could only hold two people
constraint sum([ARTIE, BILL, CRACKITT, DODGY, EDGY, FINGERS]) <= 2;

% Constraint: If Crackitt did it, Bill did it with him
constraint CRACKITT = 0 \/ (CRACKITT = 1 /\ BILL = 1);

% Constraint: Nobody did it alone
constraint ARTIE + BILL + CRACKITT + DODGY + EDGY + FINGERS >= 2;

% Constraint: Only one guilty suspect
constraint sum([ARTIE, BILL, CRACKITT, DODGY, EDGY, FINGERS]) = 1;

% Solve and output
solve satisfy;

output["Guilty suspect(s): "];
array[1..6] of var string: suspects = ["ARTIE", "BILL", "CRACKITT", "DODGY", "EDGY", "FINGERS"];
for i in 1..6 where eval(suspects[i]) = 1 do
    output[suspects[i] ++ "\n"];
end for;
___________
% Unassigned input parameters (0 - innocent, 1 - guilty)
ARTIE = 0;
BILL = 0;
CRACKITT = 0;
DODGY = 0;
EDGY = 0;
FINGERS = 0;
==============================Solution(innocent=[True, True, True, False, True, False], _checker='')
___________
% Semantic Entities
enum Suspect = { ARTIE, BILL, CRACKITT, DODGY, EDGY, FINGERS };

% Variables to represent the innocence/guilt status of each suspect
array[Suspect] of var bool: innocent;

% Constraints based on the statements
constraint innocent[ARTIE] = true;  % ARTIE: "It wasn't me."
constraint (innocent[BILL] = false) <-> (innocent[CRACKITT] = false);  % BILL: "Crackitt was in it up to his neck."
constraint innocent[CRACKITT] = true;  % CRACKITT: "No I wasn't."
constraint (innocent[DODGY] = false) <-> (innocent[BILL] /\ innocent[CRACKITT]);  % DODGY: "If Crackitt did it, Bill did it with him."
constraint innocent[EDGY] = true;  % EDGY: "Nobody did it alone."
constraint innocent[FINGERS] = false;  % FINGERS: "That’s right: it was Artie and Dodgy together."

% Additional constraints due to the fact that the getaway car could hold a maximum of two people
constraint sum([bool2int(innocent[s]) | s in Suspect]) >= 2;

% Solve the problem
solve satisfy;

% Output the guilty suspects
output["Guilty suspects: "];
output[show(s) ++ " " | s in Suspect where not innocent[s]];
___________
% Data file for the Robbery Suspect problem

% Define the innocence status of each suspect (0 for guilty, 1 for innocent)
innocent = array1d(Suspect, [0, 0, 0, 0, 0, 0]);  % Initially assume all suspects are guilty
==============================