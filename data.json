{"assess_user_input": "For the following text, state what does it contain (task, model, both or nothing). Model is a textual description of \nthe rules of a specific type of a problem, task is the input data for some problem type, and in the task, there is usually only input information without the description of the problem rules. If the text contains both the input data for some problem type and the description of it's rules, then it contains both a task, and the model. If none of the elements are present in the text, then nothing is contained in it, neither the model, nor the task. Generate one of the following words: Task, Model, Both, None, and do not generate anything else.\n\nText:\n{input}", "generate_again": "Correct the generated Mini-Zinc model, based on the textual model description, extracted semantic entities and the provided warnings from the minizinc compiler.\nUse the warnings from the minizinc compiler to correct the mistakes made in the previously generated minizinc model.\nReturn only the generated minizinc model without any additional text. And make the minizinc code print the results with the output[] statement. Very important: in the created model, leave all input parameters that are supposed to be given as inputs unassigned and write a comment next to them that says % from dzn (for example, if an input parameter would be: (int: a = 10;), leave it unassigned like this: (int: a; % from dzn) so that the values can be filled through a dzn file later).\n\nTextual model description:\n{model}\n\n\nSemantic entities extracted:\n{recognized}\n\nWarnings:\n{warnings}\n\n", "generate": "Generate a MiniZinc model, based on the textual model description and the extracted semantic entities.\nReturn only the generated MiniZinc model without any additional text. And make the MiniZinc code print the results with the output[] statement. Also in the created model, leave all input parameters that are supposed to be given as inputs unassigned (for example, if an input parameter would be: (int: a = 10;), leave it unassigned like this: (int: a;) so that the values can be filled through a dzn file later).\n\nTextual model description:\n{model}\n\nSemantic entities extracted:\n{recognized}", "recognize": "From the given text, extract the following semantic entities: Input parameters, Constraints, Relations between parameters.\n\nText:\n{input}", "RFS_new": "Based on the given minizinc model, reformat the task into input data to be witten\nin a data.dzn file which will be used by the given model when solving the modeled problem. Create the .dzn file based on the unassigned input parameters that are not assigned values in the minizinc model. Please return only the contents of the file, without any additional text.\n\nInput task:\n{input}\n\nMinizinc model:\n{model}\n\nContents of the data.dzn file:", "CFS": "Based on the given input, classify the task as one of the following tasks : \nText:\n{input}\n\n{stored_models}\n\nGenerate the output based on the given task. If the input cannot be classified as either of types of tasks, print only the word 'false'", "name_model": "Based on the problem description, assign a name to the problem type,\nwhich will be used to store a model for solving this type of problems.\n\nPrint only the assigned name, and nothing else. \nProblem description: {input}", "both": "Divide the given problem description into two parts. A part which contains the elements needed to solve the problem, or the input values to that problem type, and the other part should contain the description, rules and information on how to solve that specific type of problem. The two parts can have same elements of the input in them. Return your response in this format: Task: 'Your extracted task text' \n\nModel: 'Your extracted model text'.\n\nText:\n{input}", "G24_SCD": {"T": 3, "b": 1, "id": "g24_scd", "peers": {"A1": ["A2", "A3"], "A2": ["A1", "A3"], "A3": ["A1", "A2"]}, "variables": ["A1", "A2", "A3"]}, "sudoku_9_SCD": {"T": 81, "b": 5, "id": "sudoku_9_scd", "peers": {"A1": ["C2", "G1", "A6", "C1", "A5", "A7", "A9", "E1", "I1", "B3", "C3", "B1", "F1", "A2", "D1", "H1", "A4", "A3", "A8", "B2"], "A2": ["C2", "A6", "C1", "A5", "A7", "A9", "H2", "B3", "C3", "I2", "B1", "A1", "D2", "F2", "A4", "A3", "E2", "G2", "A8", "B2"], "A3": ["C2", "A6", "C1", "E3", "A5", "A7", "A9", "I3", "G3", "B3", "C3", "B1", "A1", "A2", "H3", "F3", "A4", "D3", "A8", "B2"], "A4": ["C5", "A6", "A5", "B5", "F4", "A7", "C4", "A9", "H4", "D4", "B6", "A1", "A2", "I4", "B4", "E4", "G4", "C6", "A3", "A8"], "A5": ["F5", "C5", "E5", "A6", "G5", "B5", "A7", "H5", "C4", "A9", "B6", "A1", "A4", "A2", "B4", "I5", "C6", "D5", "A3", "A8"], "A6": ["C5", "H6", "A5", "B5", "A7", "D6", "C4", "A9", "F6", "B6", "A1", "A2", "B4", "G6", "E6", "I6", "C6", "A4", "A3", "A8"], "A7": ["C7", "D7", "A6", "B9", "A5", "C8", "A9", "G7", "C9", "I7", "A1", "B7", "F7", "A2", "H7", "B8", "A4", "A3", "E7", "A8"], "A8": ["C7", "G8", "F8", "A6", "B9", "A5", "H8", "C8", "A7", "A9", "C9", "A1", "B7", "A4", "D8", "A2", "E8", "B8", "I8", "A3"], "A9": ["E9", "C7", "F9", "A6", "B9", "A5", "A7", "C8", "C9", "A1", "B7", "A2", "G9", "D9", "I9", "B8", "H9", "A4", "A3", "A8"], "B1": ["C2", "G1", "B9", "C1", "B5", "E1", "I1", "B3", "C3", "B6", "A1", "B7", "F1", "A2", "B4", "D1", "H1", "B8", "A3", "B2"], "B2": ["C2", "B9", "C1", "B5", "H2", "B3", "C3", "B6", "B1", "A1", "I2", "B7", "A2", "B4", "D2", "B8", "F2", "A3", "E2", "G2"], "B3": ["C2", "A3", "B9", "C1", "E3", "B5", "I3", "G3", "C3", "B6", "B1", "A1", "B7", "A2", "H3", "B4", "F3", "B8", "D3", "B2"], "B4": ["C5", "A6", "B9", "A5", "B5", "F4", "C4", "H4", "B3", "D4", "B1", "B6", "B7", "I4", "E4", "G4", "B8", "C6", "A4", "B2"], "B5": ["F5", "C5", "E5", "A6", "B9", "G5", "A5", "H5", "C4", "B3", "B6", "B1", "B7", "A4", "B4", "I5", "B8", "C6", "D5", "B2"], "B6": ["C5", "A6", "B9", "H6", "A5", "B5", "D6", "C4", "F6", "B3", "B1", "B7", "B4", "G6", "E6", "B8", "I6", "C6", "A4", "B2"], "B7": ["C7", "D7", "B9", "B5", "A7", "C8", "A9", "G7", "C9", "B3", "B6", "B1", "I7", "F7", "H7", "B4", "B8", "E7", "A8", "B2"], "B8": ["C7", "G8", "F8", "B9", "H8", "B5", "C8", "A7", "A9", "C9", "B3", "B6", "B1", "B7", "D8", "B4", "E8", "I8", "A8", "B2"], "B9": ["E9", "C7", "F9", "B5", "A7", "C8", "A9", "C9", "B3", "B6", "B1", "B7", "B4", "G9", "D9", "I9", "B8", "H9", "A8", "B2"], "C1": ["C5", "C7", "C2", "G1", "C8", "C4", "C9", "E1", "I1", "B3", "C3", "B1", "A1", "F1", "A2", "D1", "H1", "C6", "A3", "B2"], "C2": ["C5", "C7", "C1", "C8", "C4", "H2", "C9", "B3", "C3", "I2", "B1", "A1", "A2", "D2", "F2", "C6", "A3", "E2", "G2", "B2"], "C3": ["C5", "C7", "C2", "A3", "C1", "E3", "C8", "C4", "I3", "G3", "C9", "B3", "B1", "A1", "A2", "H3", "F3", "C6", "D3", "B2"], "C4": ["C5", "C7", "C2", "A6", "C1", "A5", "B5", "F4", "C8", "C9", "H4", "C3", "D4", "B6", "I4", "B4", "E4", "G4", "C6", "A4"], "C5": ["F5", "C7", "C2", "E5", "A6", "G5", "C1", "A5", "B5", "C8", "H5", "C4", "C9", "C3", "B6", "A4", "B4", "I5", "C6", "D5"], "C6": ["C5", "C7", "C2", "A6", "C1", "H6", "A5", "B5", "C8", "D6", "C4", "F6", "C9", "C3", "B6", "B4", "G6", "E6", "I6", "A4"], "C7": ["C5", "D7", "C2", "B9", "C1", "A7", "C8", "C4", "A9", "G7", "C9", "C3", "I7", "B7", "F7", "H7", "B8", "C6", "E7", "A8"], "C8": ["C5", "C7", "C2", "G8", "F8", "B9", "C1", "H8", "A7", "C4", "A9", "C9", "C3", "B7", "D8", "E8", "B8", "C6", "I8", "A8"], "C9": ["E9", "C5", "C7", "C2", "F9", "B9", "C1", "C8", "A7", "C4", "A9", "C3", "B7", "G9", "D9", "I9", "B8", "H9", "C6", "A8"], "D1": ["D7", "G1", "C1", "E3", "D6", "E1", "I1", "D4", "B1", "A1", "F1", "D8", "D2", "D9", "F3", "H1", "F2", "D5", "D3", "E2"], "D2": ["D7", "C2", "E3", "D6", "H2", "E1", "D4", "I2", "F1", "A2", "D8", "D9", "D1", "F3", "F2", "D5", "D3", "E2", "G2", "B2"], "D3": ["D7", "A3", "E3", "D6", "I3", "G3", "E1", "B3", "D4", "C3", "F1", "D8", "H3", "D2", "D9", "D1", "F3", "F2", "D5", "E2"], "D4": ["F5", "D7", "E5", "F4", "D6", "C4", "F6", "H4", "A4", "D8", "I4", "B4", "D2", "G4", "D1", "E4", "D9", "E6", "D5", "D3"], "D5": ["F5", "C5", "D7", "E5", "G5", "A5", "B5", "F4", "H5", "D6", "F6", "D4", "D8", "D2", "D9", "D1", "E4", "I5", "E6", "D3"], "D6": ["F5", "D7", "E5", "A6", "H6", "F4", "F6", "D4", "B6", "D8", "D2", "G6", "D1", "D9", "E4", "E6", "I6", "C6", "D5", "D3"], "D7": ["E9", "C7", "F9", "F8", "A7", "D6", "G7", "D4", "I7", "B7", "F7", "D8", "H7", "D2", "D9", "D1", "E8", "D5", "D3", "E7"], "D8": ["E9", "D7", "F9", "G8", "F8", "H8", "C8", "D6", "D4", "F7", "D2", "E8", "D1", "D9", "B8", "I8", "D5", "D3", "E7", "A8"], "D9": ["E9", "D7", "F9", "F8", "B9", "D6", "A9", "C9", "D4", "F7", "D8", "G9", "D2", "D1", "I9", "E8", "H9", "D5", "D3", "E7"], "E1": ["E9", "E5", "G1", "C1", "E3", "I1", "B1", "A1", "F1", "D2", "E4", "D1", "E8", "H1", "E6", "F3", "F2", "D3", "E2", "E7"], "E2": ["E9", "C2", "E5", "E3", "H2", "E1", "I2", "F1", "A2", "G2", "D2", "E4", "D1", "E8", "E6", "F3", "F2", "D3", "E7", "B2"], "E3": ["E9", "E5", "A3", "I3", "G3", "E1", "B3", "C3", "F1", "H3", "D2", "E4", "D1", "E8", "F3", "E6", "F2", "D3", "E2", "E7"], "E4": ["F5", "E9", "E5", "E3", "F4", "D6", "C4", "F6", "E1", "H4", "D4", "A4", "I4", "B4", "G4", "E8", "E6", "D5", "E2", "E7"], "E5": ["F5", "E9", "C5", "G5", "A5", "E3", "B5", "F4", "H5", "D6", "F6", "E1", "D4", "E4", "E8", "I5", "E6", "D5", "E2", "E7"], "E6": ["F5", "E9", "E5", "A6", "H6", "E3", "F4", "D6", "F6", "E1", "D4", "B6", "E4", "G6", "E8", "I6", "C6", "D5", "E2", "E7"], "E7": ["E9", "C7", "D7", "E5", "F9", "F8", "E3", "A7", "G7", "E1", "I7", "B7", "F7", "D8", "H7", "E4", "E8", "E6", "D9", "E2"], "E8": ["E9", "D7", "E5", "F9", "G8", "F8", "E3", "H8", "C8", "E1", "F7", "D8", "E4", "E6", "D9", "B8", "I8", "E2", "E7", "A8"], "E9": ["D7", "E5", "F9", "F8", "B9", "E3", "A9", "C9", "E1", "F7", "D8", "G9", "D9", "I9", "E4", "E6", "E8", "H9", "E2", "E7"], "F1": ["F5", "F9", "F8", "G1", "C1", "E3", "F4", "F6", "E1", "I1", "B1", "A1", "F7", "D2", "D1", "F3", "H1", "F2", "D3", "E2"], "F2": ["F5", "C2", "F9", "F8", "E3", "F4", "F6", "H2", "E1", "I2", "F7", "A2", "F1", "D2", "D1", "F3", "D3", "E2", "G2", "B2"], "F3": ["F5", "F9", "F8", "A3", "E3", "F4", "I3", "G3", "F6", "E1", "B3", "C3", "F7", "F1", "H3", "D2", "D1", "F2", "D3", "E2"], "F4": ["F5", "E5", "F9", "F8", "D6", "C4", "F6", "H4", "D4", "A4", "F7", "F1", "I4", "B4", "E4", "G4", "F3", "E6", "F2", "D5"], "F5": ["C5", "E5", "F9", "F8", "G5", "A5", "B5", "F4", "H5", "D6", "F6", "D4", "F7", "F1", "E4", "I5", "F3", "E6", "F2", "D5"], "F6": ["F5", "E5", "F9", "F8", "A6", "H6", "F4", "D6", "D4", "B6", "F7", "F1", "E4", "G6", "E6", "F3", "I6", "F2", "C6", "D5"], "F7": ["F5", "E9", "C7", "D7", "F9", "F8", "F4", "A7", "G7", "F6", "I7", "B7", "D8", "F1", "H7", "D9", "E8", "F3", "F2", "E7"], "F8": ["F5", "E9", "D7", "F9", "G8", "H8", "F4", "C8", "F6", "F7", "D8", "F1", "E8", "D9", "F3", "B8", "F2", "I8", "E7", "A8"], "F9": ["F5", "E9", "D7", "F8", "B9", "F4", "A9", "F6", "C9", "F7", "D8", "F1", "G9", "D9", "I9", "F3", "E8", "F2", "H9", "E7"], "G1": ["G8", "C1", "G5", "G7", "G3", "H2", "E1", "I1", "I3", "I2", "B1", "A1", "F1", "H3", "G9", "G4", "D1", "G6", "H1", "G2"], "G2": ["C2", "G8", "G1", "G5", "G7", "G3", "H2", "I3", "I1", "I2", "A2", "H3", "D2", "G4", "G6", "G9", "H1", "F2", "E2", "B2"], "G3": ["G8", "G1", "A3", "G5", "E3", "I3", "G7", "H2", "I1", "B3", "C3", "I2", "H3", "G9", "G4", "G6", "F3", "H1", "D3", "G2"], "G4": ["G8", "G1", "G5", "H6", "F4", "H5", "C4", "G7", "G3", "H4", "D4", "I4", "B4", "G9", "G6", "E4", "I5", "I6", "A4", "G2"], "G5": ["F5", "C5", "E5", "G8", "G1", "A5", "H6", "B5", "H5", "G7", "G3", "H4", "I4", "G9", "G4", "G6", "I5", "I6", "D5", "G2"], "G6": ["G8", "G1", "A6", "G5", "H6", "H5", "D6", "G7", "G3", "F6", "H4", "B6", "I4", "G9", "G4", "E6", "I5", "I6", "C6", "G2"], "G7": ["C7", "D7", "G8", "E7", "G1", "G5", "H8", "A7", "G3", "I7", "B7", "F7", "H7", "G9", "G4", "G6", "I9", "H9", "I8", "G2"], "G8": ["F8", "G1", "G5", "H8", "C8", "G7", "G3", "I7", "D8", "H7", "G9", "G4", "G6", "E8", "B8", "I9", "H9", "I8", "G2", "A8"], "G9": ["E9", "F9", "G8", "G1", "B9", "G5", "H8", "G3", "G7", "A9", "C9", "I7", "H7", "G4", "G6", "D9", "I9", "H9", "I8", "G2"], "H1": ["G1", "C1", "H6", "H8", "H5", "G3", "I3", "H2", "E1", "I1", "H4", "I2", "B1", "A1", "F1", "H7", "H3", "D1", "H9", "G2"], "H2": ["C2", "G1", "H6", "H8", "H5", "G3", "I3", "I1", "H4", "I2", "A2", "H7", "H3", "D2", "H1", "F2", "H9", "E2", "G2", "B2"], "H3": ["G1", "A3", "E3", "H6", "H8", "H5", "I3", "G3", "H2", "I1", "H4", "B3", "C3", "I2", "H7", "F3", "H1", "H9", "D3", "G2"], "H4": ["G5", "H6", "H8", "F4", "H5", "C4", "H2", "D4", "H7", "I4", "B4", "E4", "G4", "G6", "H3", "H1", "I5", "I6", "H9", "A4"], "H5": ["F5", "C5", "E5", "G5", "A5", "H6", "H8", "B5", "H2", "H4", "H7", "I4", "H3", "G4", "G6", "I5", "H1", "I6", "H9", "D5"], "H6": ["A6", "G5", "H8", "H5", "D6", "F6", "H2", "H4", "B6", "H7", "I4", "H3", "G4", "G6", "E6", "H1", "I5", "I6", "H9", "C6"], "H7": ["C7", "D7", "G8", "H6", "H8", "A7", "H5", "G7", "H2", "H4", "I7", "B7", "F7", "H3", "G9", "I9", "H1", "H9", "I8", "E7"], "H8": ["G8", "F8", "H6", "C8", "H5", "G7", "H2", "H4", "I7", "D8", "H7", "H3", "G9", "E8", "I9", "B8", "H1", "H9", "I8", "A8"], "H9": ["E9", "F9", "G8", "B9", "H6", "H8", "H5", "G7", "A9", "H2", "C9", "H4", "I7", "H7", "H3", "G9", "D9", "I9", "H1", "I8"], "I1": ["G1", "C1", "G3", "I3", "H2", "E1", "I2", "B1", "A1", "I7", "F1", "I4", "H3", "I9", "D1", "I5", "H1", "I6", "I8", "G2"], "I2": ["C2", "G1", "G3", "I3", "H2", "I1", "I7", "A2", "I4", "H3", "D2", "I9", "I5", "H1", "I6", "F2", "I8", "E2", "G2", "B2"], "I3": ["G1", "A3", "E3", "G3", "H2", "I1", "B3", "C3", "I2", "I7", "I4", "H3", "I9", "F3", "I5", "H1", "I6", "I8", "D3", "G2"], "I4": ["G5", "H6", "F4", "H5", "C4", "I3", "I1", "H4", "D4", "I2", "I7", "A4", "B4", "E4", "G4", "G6", "I9", "I5", "I6", "I8"], "I5": ["F5", "C5", "E5", "D5", "G5", "A5", "H6", "B5", "H5", "I3", "I1", "H4", "I2", "I7", "I4", "G4", "G6", "I9", "I6", "I8"], "I6": ["A6", "G5", "H6", "H5", "D6", "I3", "F6", "I1", "H4", "B6", "I2", "I7", "I4", "G4", "G6", "I9", "E6", "I5", "C6", "I8"], "I7": ["C7", "D7", "G8", "H8", "A7", "G7", "I3", "I1", "I2", "B7", "F7", "H7", "I4", "G9", "I9", "I5", "I6", "H9", "I8", "E7"], "I8": ["G8", "F8", "H8", "C8", "G7", "I3", "I1", "I2", "I7", "D8", "H7", "I4", "G9", "E8", "I9", "I5", "B8", "I6", "H9", "A8"], "I9": ["E9", "F9", "G8", "B9", "H8", "G7", "A9", "C9", "I3", "I1", "I2", "I7", "H7", "I4", "G9", "D9", "I5", "I6", "H9", "I8"]}, "variables": ["A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8", "G9", "H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "I1", "I2", "I3", "I4", "I5", "I6", "I7", "I8", "I9"], "domains": {"A1": "123456789", "A2": "123456789", "A3": "123456789", "A4": "123456789", "A5": "123456789", "A6": "123456789", "A7": "123456789", "A8": "123456789", "A9": "123456789", "B1": "123456789", "B2": "123456789", "B3": "123456789", "B4": "123456789", "B5": "123456789", "B6": "123456789", "B7": "123456789", "B8": "123456789", "B9": "123456789", "C1": "123456789", "C2": "123456789", "C3": "123456789", "C4": "123456789", "C5": "123456789", "C6": "123456789", "C7": "123456789", "C8": "123456789", "C9": "123456789", "D1": "123456789", "D2": "123456789", "D3": "123456789", "D4": "123456789", "D5": "123456789", "D6": "123456789", "D7": "123456789", "D8": "123456789", "D9": "123456789", "E1": "123456789", "E2": "123456789", "E3": "123456789", "E4": "123456789", "E5": "123456789", "E6": "123456789", "E7": "123456789", "E8": "123456789", "E9": "123456789", "F1": "123456789", "F2": "123456789", "F3": "123456789", "F4": "123456789", "F5": "123456789", "F6": "123456789", "F7": "123456789", "F8": "123456789", "F9": "123456789", "G1": "123456789", "G2": "123456789", "G3": "123456789", "G4": "123456789", "G5": "123456789", "G6": "123456789", "G7": "123456789", "G8": "123456789", "G9": "123456789", "H1": "123456789", "H2": "123456789", "H3": "123456789", "H4": "123456789", "H5": "123456789", "H6": "123456789", "H7": "123456789", "H8": "123456789", "H9": "123456789", "I1": "123456789", "I2": "123456789", "I3": "123456789", "I4": "123456789", "I5": "123456789", "I6": "123456789", "I7": "123456789", "I8": "123456789", "I9": "123456789"}}, "sudoku_6_SCD": {"peers": {"A1": ["A5", "A4", "A6", "E1", "B1", "B3", "B2", "A2", "C1", "A3", "D1", "F1"], "A2": ["F2", "A5", "A4", "A6", "D2", "B1", "B3", "B2", "C2", "E2", "A3", "A1"], "A3": ["A5", "A4", "E3", "A6", "B1", "D3", "B3", "C3", "B2", "F3", "A2", "A1"], "A4": ["A5", "A6", "F4", "D4", "B4", "A2", "A3", "B6", "C4", "A1", "E4", "B5"], "A5": ["A4", "A6", "E5", "B4", "F5", "A2", "C5", "D5", "A3", "B6", "A1", "B5"], "A6": ["A5", "A4", "C6", "B4", "D6", "E6", "A2", "B6", "A3", "F6", "A1", "B5"], "B1": ["E1", "B3", "B4", "B2", "A2", "C1", "A3", "D1", "B6", "A1", "B5", "F1"], "B2": ["F2", "D2", "B1", "B3", "B4", "C2", "A2", "B6", "E2", "A3", "A1", "B5"], "B3": ["E3", "C3", "D3", "B1", "B4", "B2", "F3", "A2", "B6", "A3", "A1", "B5"], "B4": ["A5", "A4", "A6", "B1", "F4", "B3", "D4", "B2", "B6", "C4", "E4", "B5"], "B5": ["A5", "A4", "A6", "E5", "B1", "B3", "B4", "F5", "B2", "C5", "D5", "B6"], "B6": ["A5", "A4", "C6", "A6", "B1", "B3", "B4", "D6", "E6", "B2", "F6", "B5"], "C1": ["C6", "E1", "D2", "B1", "D3", "C3", "C2", "C5", "D1", "C4", "A1", "F1"], "C2": ["F2", "C6", "D2", "C3", "D3", "B2", "A2", "C1", "C5", "E2", "C4", "D1"], "C3": ["E3", "C6", "D2", "D3", "B3", "C2", "F3", "C1", "C5", "A3", "C4", "D1"], "C4": ["A4", "C6", "C3", "F4", "D4", "B4", "D6", "C2", "C1", "C5", "D5", "E4"], "C5": ["A5", "C6", "E5", "C3", "D4", "D6", "F5", "C2", "C1", "D5", "C4", "B5"], "C6": ["A6", "C3", "D4", "D6", "E6", "C2", "B6", "C1", "C5", "D5", "F6", "C4"], "D1": ["E1", "D2", "B1", "D3", "C3", "D4", "D6", "C2", "C1", "D5", "A1", "F1"], "D2": ["F2", "C3", "D3", "D4", "D6", "B2", "C2", "A2", "C1", "D5", "E2", "D1"], "D3": ["E3", "D2", "C3", "B3", "D4", "D6", "C2", "F3", "C1", "D5", "A3", "D1"], "D4": ["A4", "C6", "D2", "F4", "D3", "B4", "D6", "C5", "D5", "C4", "D1", "E4"], "D5": ["A5", "C6", "D2", "E5", "D3", "D4", "D6", "F5", "C5", "C4", "D1", "B5"], "D6": ["C6", "A6", "D2", "D3", "D4", "E6", "B6", "C5", "D5", "F6", "C4", "D1"], "E1": ["F2", "E3", "E5", "B1", "E6", "F3", "C1", "D1", "E2", "A1", "E4", "F1"], "E2": ["F2", "E3", "E1", "D2", "E5", "E6", "B2", "C2", "F3", "A2", "E4", "F1"], "E3": ["F2", "E1", "E5", "C3", "D3", "B3", "E6", "F3", "A3", "E2", "E4", "F1"], "E4": ["E3", "A4", "E1", "E5", "F4", "D4", "B4", "F5", "E6", "F6", "C4", "E2"], "E5": ["A5", "E3", "E1", "F4", "F5", "E6", "C5", "D5", "F6", "E2", "E4", "B5"], "E6": ["E3", "C6", "A6", "E1", "E5", "F4", "D6", "F5", "B6", "F6", "E2", "E4"], "F1": ["F2", "E3", "E1", "B1", "F4", "F5", "F3", "C1", "D1", "F6", "E2", "A1"], "F2": ["E3", "E1", "D2", "F4", "F5", "B2", "C2", "F3", "A2", "F6", "E2", "F1"], "F3": ["F2", "E3", "E1", "C3", "F4", "D3", "B3", "F5", "E2", "F6", "A3", "F1"], "F4": ["F2", "A4", "E5", "D4", "B4", "F5", "E6", "F3", "F6", "C4", "E4", "F1"], "F5": ["F2", "A5", "E5", "F4", "E6", "F3", "C5", "D5", "F6", "E4", "B5", "F1"], "F6": ["F2", "C6", "A6", "E5", "F4", "D6", "E6", "F5", "F3", "B6", "E4", "F1"]}, "T": 36, "b": 5, "id": "sudoku_6_scd", "variables": ["A1", "A2", "A3", "A4", "A5", "A6", "B1", "B2", "B3", "B4", "B5", "B6", "C1", "C2", "C3", "C4", "C5", "C6", "D1", "D2", "D3", "D4", "D5", "D6", "E1", "E2", "E3", "E4", "E5", "E6", "F1", "F2", "F3", "F4", "F5", "F6"], "domains": {"A1": "123456", "A2": "123456", "A3": "123456", "A4": "123456", "A5": "123456", "A6": "123456", "B1": "123456", "B2": "123456", "B3": "123456", "B4": "123456", "B5": "123456", "B6": "123456", "C1": "123456", "C2": "123456", "C3": "123456", "C4": "123456", "C5": "123456", "C6": "123456", "D1": "123456", "D2": "123456", "D3": "123456", "D4": "123456", "D5": "123456", "D6": "123456", "E1": "123456", "E2": "123456", "E3": "123456", "E4": "123456", "E5": "123456", "E6": "123456", "F1": "123456", "F2": "123456", "F3": "123456", "F4": "123456", "F5": "123456", "F6": "123456"}}, "sudoku_4_SCD": {"T": 16, "b": 1, "id": "sudoku_4_scd", "peers": {"A1": ["C1", "A3", "A2", "B1", "A4", "B2", "D1"], "A2": ["D2", "A3", "C2", "A1", "A4", "B2", "B1"], "A3": ["C3", "D3", "B3", "A2", "B4", "A1", "A4"], "A4": ["D4", "A3", "B3", "A2", "A1", "B4", "C4"], "B1": ["C1", "B3", "A2", "A1", "B4", "B2", "D1"], "B2": ["D2", "B3", "C2", "A2", "A1", "B4", "B1"], "B3": ["C3", "A3", "D3", "B4", "A4", "B2", "B1"], "B4": ["D4", "A3", "B3", "A4", "C4", "B2", "B1"], "C1": ["C3", "D2", "C2", "A1", "D1", "C4", "B1"], "C2": ["C3", "C1", "D2", "A2", "D1", "C4", "B2"], "C3": ["D4", "C1", "A3", "B3", "C2", "D3", "C4"], "C4": ["C3", "D4", "C1", "C2", "D3", "B4", "A4"], "D1": ["D4", "C1", "D2", "C2", "D3", "A1", "B1"], "D2": ["D4", "C1", "C2", "A2", "D3", "D1", "B2"], "D3": ["C3", "D4", "D2", "A3", "B3", "D1", "C4"], "D4": ["C3", "D2", "A4", "D3", "B4", "D1", "C4"]}, "variables": ["A1", "A2", "A3", "A4", "B1", "B2", "B3", "B4", "C1", "C2", "C3", "C4", "D1", "D2", "D3", "D4"], "domains": {"A1": "1234", "A2": "1234", "A3": "1234", "A4": "1234", "B1": "1234", "B2": "1234", "B3": "1234", "B4": "1234", "C1": "1234", "C2": "1234", "C3": "1234", "C4": "1234", "D1": "1234", "D2": "1234", "D3": "1234", "D4": "1234"}}, "progress_tree": "", "stored_models": {"sudoku_9x9": "", "sudoku_6x6": "", "sudoku_4x4": "", "Concert Ticket Selling Problem": "int: vip_seats; % Number of VIP seatsXXxnint: regular_seats; % Number of Regular seatsXXxnint: vip_price; % Price per VIP ticketXXxnint: regular_price; % Price per Regular ticketXXxnint: required_free_seats; % Required number of free seats for special guestsXXxnint: total_price_goal; % Total price goalXXxnint: total_expenses; % Total expenses (including staff salaries and funds for the concert)XXxnXXxn% Decision variablesXXxnvar 0..vip_seats: vip_tickets_sold; % VIP tickets soldXXxnvar 0..regular_seats: regular_tickets_sold; % Regular tickets soldXXxnXXxn% ConstraintsXXxnconstraint vip_tickets_sold + regular_tickets_sold <= vip_seats + regular_seats; % Total tickets sold should not exceed available seatsXXxnconstraint required_free_seats <= vip_tickets_sold; % Required free seats for special guests are accommodatedXXxnconstraint vip_tickets_sold * vip_price + regular_tickets_sold * regular_price >= total_price_goal; % Total price goal is metXXxnXXxn% Objective: Maximize profitXXxnvar int: total_revenue = vip_tickets_sold * vip_price + regular_tickets_sold * regular_price;XXxnvar int: profit = total_revenue - total_expenses;XXxnXXxnsolve maximize profit;XXxnXXxn% OutputXXxnoutput ['VIP tickets sold: ', show(vip_tickets_sold), 'XXxn', 'Regular tickets sold: ', show(regular_tickets_sold), 'XXxn', 'Total revenue: ', show(total_revenue), 'XXxn', 'Total expenses: ', show(total_expenses), 'XXxn', 'Profit: ', show(profit)];", "Concert Ticket Selling\u95ee\u9898\u3002": "% Parameters\r\nint: n; % Total seats\r\nint: m; % VIP seats\r\nint: P_vip; % VIP ticket price\r\nint: P_regular; % Regular ticket price\r\nint: k_free; % Free seats for special guests\r\nint: total_goal; % Total price goal\r\nint: expenses; % Expenses (staff salary, concert fund, etc.)\r\n\r\n% Constraints\r\nconstraint n >= m /XXx n >= k_free; % Ensure enough seats for VIP and special guests\r\nconstraint m >= 0 /XXx k_free >= 0; % Non-negativity of VIP and special guest seats\r\nconstraint total_goal >= 0 /XXx expenses >= 0; % Non-negativity of total goal and expenses\r\n\r\n% Calculate the total revenue\r\nvar int: revenue_vip = P_vip * (m - k_free); % Only non-free VIP seats are sold\r\nvar int: revenue_regular = P_regular * (n - m); % Regular tickets sold to remaining seats\r\nvar int: total_revenue = revenue_vip + revenue_regular;\r\n\r\n% Calculate the profit\r\nvar int: profit = total_revenue - expenses;\r\n\r\n% Ensure that the required number of special guest seats is available\r\nconstraint k_free <= n - m; % Ensure we have enough total seats to accommodate k_free\r\n\r\n% Ensure the total goal is met\r\nconstraint total_revenue >= total_goal;\r\n\r\n% Optimize the profit\r\nsolve maximize profit;\r\n\r\n% Output the results\r\noutput['Total revenue: ' ++ show(total_revenue) ++ 'XXxn'];\r\noutput['Profit: ' ++ show(profit) ++ 'XXxn'];", "Concert Ticket Selling\u95ee\u9898": "% Variables:  VIP and Regular Seats\nint: total_seats = 1000; % from dzn\nint: vip_seats = 200;\nint: regular_seats = total_seats - vip_seats;\n\n% Ticket prices\nint: vip_price = 170;\nint: regular_price = 60;\n\n% Special Guest Seats\nint: special_guest_seats = 400; % from dzn\n\n% Expenses\nint: staff_salary = 20000;\nint: concert_fund = 25000;\nint: total_expenses = staff_salary + concert_fund;\n\n% Required number of special guest seats\nconstraint special_guest_seats <= special_guest_seats;\n\n% Revenue from ticket sales\nvar int: vip_revenue = vip_seats * vip_price;\nvar int: regular_revenue = regular_seats * regular_price;\nvar int: total_revenue = vip_revenue + regular_revenue;\n\n% Total price goal\nint: total_price_goal = 160000; % from dzn\n\n% Profit calculation\nvar int: profit = total_revenue - total_expenses;\n\n% Constraints\nconstraint total_seats = vip_seats + regular_seats;\nconstraint total_revenue >= total_price_goal;\nconstraint profit >= 0;\n\nsolve satisfy;\n\n% Output\noutput['VIP Seats: XXx(vip_seats)XXxn'];\noutput['Regular Seats: XXx(regular_seats)XXxn'];\noutput['Special Guest Seats: XXx(special_guest_seats)XXxn'];\noutput['Total Revenue: XXx(total_revenue)XXxn'];\noutput['Profit: XXx(profit)XXxn'];", "Profit Maximization Problem": "int: total_seats; % from dzn\nint: num_vip_seats; % from dzn\nint: price_vip_seat = 170;\nint: num_free_seats_special_guests; % from dzn\nint: price_regular_seat = 60;\nint: total_price_goal; % from dzn\n\nvar 0..num_vip_seats: num_regular_seats;\nvar 0..num_free_seats_special_guests: num_regular_seats_special_guests;\n\nconstraint num_vip_seats + num_free_seats_special_guests + num_regular_seats = total_seats;\nconstraint num_vip_seats * price_vip_seat + num_free_seats_special_guests * 0 + num_regular_seats * price_regular_seat = total_price_goal;\nconstraint num_vip_seats <= 200;\nconstraint num_free_seats_special_guests <= 400;\nconstraint num_regular_seats >= 400;\n\nvar int: total_profit = num_vip_seats * (price_vip_seat - 100) + num_regular_seats * (price_regular_seat - 20);\n\nsolve maximize total_profit;\n\noutput ['Total profit: XXx(total_profit)'];", "Board Allocation Problem": "int: n; % Number of different types of boardsXXxnint: m; % Number of available slotsXXxnXXxn% BOARD types: B1, B2, B3XXxnint: B1; % Quantity of B1 boardsXXxnint: B2; % Quantity of B2 boardsXXxnint: B3; % Quantity of B3 boardsXXxnXXxn% LBOARD types: L1, L2XXxnint: L1; % Quantity of L1 boardsXXxnint: L2; % Quantity of L2 boardsXXxnXXxn% Allowed slots for each board typeXXxnset of int: allowed_B1 = 1..m; % Allowed slots for B1XXxnset of int: allowed_B2 = 1..m; % Allowed slots for B2XXxnset of int: allowed_B3 = 1..m; % Allowed slots for B3XXxnset of int: allowed_L1 = 1..m; % Allowed slots for L1XXxnset of int: allowed_L2 = 1..m; % Allowed slots for L2XXxnXXxn% Decision variablesXXxnarray[1..m] of var 0..3: slots; % 0 = empty, 1 = B1, 2 = B2, 3 = B3, 4 = L1, 5 = L2XXxnXXxn% ConstraintsXXxn% Constraints for BOARD types (B1, B2, B3)XXxnconstraint forall(i in 1..m) (XXxn    if slots[i] = 1 thenXXxn        i in allowed_B1XXxn    elseif slots[i] = 2 thenXXxn        i in allowed_B2XXxn    elseif slots[i] = 3 thenXXxn        i in allowed_B3XXxn    elseXXxn        true % Empty slotXXxn    endifXXxn);XXxnXXxn% Constraints for LBOARD types (L1, L2)XXxnconstraint forall(i in 1..m-1) (XXxn    if slots[i] = 4 thenXXxn        slots[i+1] = 4 /XXxXXxn        i in allowed_L1 /XXxXXxn        i+1 in allowed_L1XXxn    elseif slots[i] = 5 thenXXxn        slots[i+1] = 5 /XXxXXxn        i in allowed_L2 /XXxXXxn        i+1 in allowed_L2XXxn    elseXXxn        true % Not an LBOARD slotXXxn    endifXXxn);XXxnXXxn% Quantity constraintsXXxnconstraint sum(i in 1..m)(if slots[i] = 1 then 1 else 0 endif) <= B1; % B1 boardsXXxnconstraint sum(i in 1..m)(if slots[i] = 2 then 1 else 0 endif) <= B2; % B2 boardsXXxnconstraint sum(i in 1..m)(if slots[i] = 3 then 1 else 0 endif) <= B3; % B3 boardsXXxnconstraint sum(i in 1..m-1)(if slots[i] = 4 then 1 else 0 endif) <= L1; % LBOARD1XXxnconstraint sum(i in 1..m-1)(if slots[i] = 5 then 1 else 0 endif) <= L2; % LBOARD2XXxnXXxn% Objective: No specific objective, just find a valid allocationXXxnsolve satisfy;XXxnXXxn% OutputXXxnoutput [XXxn  'Board Allocation:XXxn',XXxn  '====================XXxn',XXxn  concat([if slots[i] = 0 then '.' else if slots[i] = 1 then 'B1' else if slots[i] = 2 then 'B2' else if slots[i] = 3 then 'B3' else if slots[i] = 4 then 'L1' else 'L2' endif endif endif endif endif end if | i in 1..m]),XXxn  'XXxn====================' ];", "Fixed Orientation Bin Packing Problem": "% Parameters\nint: n_items;          % Number of items\nint: n_bins;           % Number of bins\narray[1..n_items] of int: item_widths;   % Width of each item\narray[1..n_items] of int: item_heights;  % Height of each item\narray[1..n_items] of int: item_depths;   % Depth of each item\nint: bin_width;         % Width of each bin\nint: bin_height;        % Height of each bin\nint: bin_depth;         % Depth of each bin\nint: bin_capacity;      % Maximum volume of items in a bin\n\n% Decision variables\n% bin_assignment[i] = j means item i is assigned to bin j\narray[1..n_items] of var 1..n_bins: bin_assignment;\n\n% Constraints\n% Items must fit within the dimensions of the bins\nconstraint forall(i in 1..n_items)(\n    item_widths[i] <= bin_width /XXx item_heights[i] <= bin_height /XXx item_depths[i] <= bin_depth\n);\n\n% Total volume of items in each bin must not exceed the capacity of the bin\nconstraint forall(j in 1..n_bins)(\n    sum(i in 1..n_items where bin_assignment[i] == j)(item_widths[i] * item_heights[i] * item_depths[i]) <= bin_capacity\n);\n\n% Geometric planes must not intersect - not explicitly modeled here, assumed to be given as input\n\n% Objective: Minimize the number of bins used\nvar int: used_bins = max(bin_assignment);\n\nsolve minimize used_bins;\n\n% Output\noutput['Bins used: XXx(used_bins)'];", "Constraint Satisfaction Problem": "% Constants\nint: available_seats = 600; % from dzn\nint: vip_seat_limit = 200;\nint: free_seat_limit = 400;\nint: required_free_seats_special = 400;\nint: vip_ticket_price = 200;\nint: regular_ticket_price = 100;\nint: total_expenses = 45000;\n\n% Variables\nvar 0..available_seats: vip_tickets_sold; \nvar 0..available_seats: regular_tickets_sold; % We don't know the upper limit for regular tickets sold\n\n% Constraints\nconstraint vip_tickets_sold <= vip_seat_limit;\nconstraint regular_tickets_sold + vip_tickets_sold <= available_seats;\nconstraint vip_tickets_sold * vip_ticket_price + regular_tickets_sold * regular_ticket_price >= total_expenses;\n\n% Objective\nvar int: total_revenue = vip_tickets_sold * vip_ticket_price + regular_tickets_sold * regular_ticket_price;\nvar int: total_profit = total_revenue - total_expenses;\n\nsolve maximize total_profit;\n\noutput ['Total Revenue: ' ++ show(total_revenue) ++ 'XXxn' ++\n        'Total Profit: ' ++ show(total_profit) ++ 'XXxn' ++\n        'VIP Tickets Sold: ' ++ show(vip_tickets_sold) ++ 'XXxn' ++\n        'Regular Tickets Sold: ' ++ show(regular_tickets_sold) ++ 'XXxn'];", "Seat Allocation Problem": "% Parameters\nint: total_seats; % Total available seats (from dzn)\nint: vip_max = 200; % Maximum VIP seats\nint: free_max = 400; % Maximum free seats\nint: special_guest_seats_req = 50; % Required number of special guest seats\nint: ticket_cost = 10; % Cost per regular ticket\nint: vip_price = 50; % Price per VIP ticket\nint: regular_price = 30; % Price per regular ticket\nint: special_guest_price = 40; % Price per special guest ticket\nint: staff_salary = 1000; % Monthly staff salary\nint: concert_fund = 500; % Monthly concert fund\nint: total_price_goal = 10000; % Desired total revenue\n\n% Decision variables\nvar 0..vip_max: vip_sold; % VIP tickets sold\nvar 0..(total_seats - vip_max): regular_sold; % Regular tickets sold\n\n% Special guest seats are not sold, they are reserved\nconstraint vip_sold + regular_sold + special_guest_seats_req <= total_seats;\nconstraint vip_sold <= vip_max;\nconstraint regular_sold <= (total_seats - vip_max);\nconstraint vip_sold * vip_price + regular_sold * regular_price + special_guest_seats_req * special_guest_price >= total_price_goal;\n% Expenses calculation\nvar int: total_revenue = vip_sold * vip_price + regular_sold * regular_price + special_guest_seats_req * special_guest_price;\nvar int: total_expenses = staff_salary + concert_fund;\nvar int: profit = total_revenue - total_expenses;\nvar int: goal_profit = profit - total_price_goal;\n\nsolve maximize goal_profit;\n\noutput ['VIP tickets: ', show(vip_sold), 'XXxn',\n        'Regular tickets: ', show(regular_sold), 'XXxn',\n        'Special guest seats: ', show(special_guest_seats_req), 'XXxn',\n        'Total revenue: ', show(total_revenue), 'XXxn',\n        'Total expenses: ', show(total_expenses), 'XXxn',\n        'Profit: ', show(profit), 'XXxn',\n        'Goal Profit: ', show(goal_profit), 'XXxn'];", "Profit maximization problem.": "% Ensure that the total revenue from ticket sales is greater than the total expenses, including staff salary and concert fund.\n% The profit is calculated by subtracting expenses from the total revenue.\n% Accommodate special guests by ensuring the availability of the required number of free seats.\n% The total price goal should be met by selling tickets.\n\nint: ticket_price = 50; % Price of each ticket\nint: total_seats = 200; % Total seats in the concert hall\nint: free_seats_for_special_guests = 20; % Number of free seats for special guests\nint: special_guests = 2; % Number of special guests\nint: staff_salary = 1000; % Staff salary for the concert\nint: concert_fund = 500; % Additional expenses for the concert\nint: total_price_goal = 8000; % Total revenue goal\n\n% Decision variables\nvar int: regular_tickets_sold; % Number of regular tickets sold\nvar int: profit; % Total profit from the concert\n\n% Constraints\nconstraint regular_tickets_sold >= 0 /XXx regular_tickets_sold + special_guests <= total_seats;\nconstraint regular_tickets_sold * ticket_price + special_guests * ticket_price == total_price_goal;\nconstraint profit == (regular_tickets_sold * ticket_price) - (staff_salary + concert_fund);\n\nsolve satisfy;\n\noutput['Regular Tickets Sold: ', show(regular_tickets_sold), 'XXxn'];\noutput['Special Guests: ', show(special_guests), 'XXxn'];\noutput['Total Revenue: ', show(regular_tickets_sold * ticket_price + special_guests * ticket_price), 'XXxn'];\noutput['Total Expenses: ', show(staff_salary + concert_fund), 'XXxn'];\noutput['Profit: ', show(profit), 'XXxn'];", "Classroom Scheduling Problem": "int: n;  % Number of classrooms available\nint: m;  % Maximum hours each classroom can be used per day\nint: k;  % Number of classes\nint: z;  % Maximum number of subjects a class can have per week\n\n% Matrix for the quantity of sessions needed for each class in each subject over the week\n% Rows correspond to classes, columns to subjects (A, B, C, D)\narray[1..k, 1..4] of int: ClassSubjectQty;\n\n% Our week has 5 days with 3 hours each, so a total of 15 hours per week\nint: totalHoursPerWeek = 15;\n\n% Subject hours available per day\nint: hoursPerDay = 3;\n\n% Ensure that we can satisfy the required hours for each subject\nconstraint\n    forall(j in 1..4) (\n        sum(i in 1..k)(ClassSubjectQty[i, j]) <= totalHoursPerWeek\n    );\n\n% Ensure that each class does not exceed the maximum hours per day for a subject\nconstraint\n    forall(i in 1..k, d in 1..5) (\n        sum(j in 1..4)(ClassSubjectQty[i, j]) <= m\n    );\n\n% Ensure that each class does not exceed the maximum number of subjects per week\nconstraint\n    forall(i in 1..k) (\n        sum(j in 1..4)(if ClassSubjectQty[i, j] > 0 then 1 else 0 endif) <= z\n    );\n\n% Find the optimal allocation of hours for each subject in each classroom\n% There are no preferences or optimizations stated, so we just aim to meet the requirements\n\n% Decision variable: Number of hours allocated for each subject in each classroom\narray[1..n, 1..4] of var 0..totalHoursPerWeek: SubjectHours;\n\n% Constraint: Each classroom cannot exceed the daily hours limit\nconstraint\n    forall(d in 1..5, c in 1..n) (\n        sum(s in 1..4)(SubjectHours[c, s]) <= hoursPerDay\n    );\n\n% Constraint: Each class gets required hours in each subject\nconstraint\n    forall(i in 1..k, j in 1..4) (\n        sum(c in 1..n)(SubjectHours[c, j]) >= ClassSubjectQty[i, j]\n    );\n\nsolve satisfy;\n\noutput [\n    'Classrooms Schedule:XXxn'\n] ++\n[\n    if c = 1 then 'XXxnClassroom ' ++ show(c) ++ ':XXxn' else '' endif ++\n    'Subject A: ' ++ show(SubjectHours[c, 1]) ++ ' hoursXXxn' ++\n    'Subject B: ' ++ show(SubjectHours[c, 2]) ++ ' hoursXXxn' ++\n    'Subject C: ' ++ show(SubjectHours[c, 3]) ++ ' hoursXXxn' ++\n    'Subject D: ' ++ show(SubjectHours[c, 4]) ++ ' hoursXXxn'\n    | c in 1..n\n];", "3D Bin Packing Problem": "```minizinc\n% MiniZinc model for 3D Bin Packing Problem\n\n% Input Parameters\nint: num_items;\nset of int: ITEMS = 1..num_items;\n\narray[ITEMS, 1..3] of int: item_dimensions; % Dimensions of each item (width, height, depth)\narray[1..3] of int: space_dimensions = [10, 10, 10]; % Dimensions of the 3-dimensional space\n\n% Decision Variables\narray[ITEMS, 1..3] of var 0..space_dimensions[1]: item_positions_x; % X coordinates of item positions\narray[ITEMS, 1..3] of var 0..space_dimensions[2]: item_positions_y; % Y coordinates of item positions\narray[ITEMS, 1..3] of var 0..space_dimensions[3]: item_positions_z; % Z coordinates of item positions\n\n% Constraints\nconstraint forall(i in ITEMS)(\n    item_positions_x[i, 1] + item_dimensions[i, 1] <= space_dimensions[1] % Check width constraint\n    /XXx item_positions_y[i, 1] + item_dimensions[i, 2] <= space_dimensions[2] % Check height constraint\n    /XXx item_positions_z[i, 1] + item_dimensions[i, 3] <= space_dimensions[3] % Check depth constraint\n);\n\nsolve satisfy;\n\n% Output\noutput [item_positions_x, item_positions_y, item_positions_z];\n```", "Bin Packing Problem": "include 'globals.mzn';XXxnXXxn% ParametersXXxnint: n; % Number of itemsXXxnarray[1..n] of int: item_width; % Width of each itemXXxnarray[1..n] of int: item_height; % Height of each itemXXxnarray[1..n] of int: item_depth; % Depth of each itemXXxnint: bin_width; % Width of the binXXxnint: bin_height; % Height of the binXXxnint: bin_depth; % Depth of the binXXxnXXxn% VariablesXXxnarray[1..n] of var 0..bin_width: x; % x-coordinate of each item in the binXXxnarray[1..n] of var 0..bin_height: y; % y-coordinate of each item in the binXXxnarray[1..n] of var 0..bin_depth: z; % z-coordinate of each item in the binXXxnXXxn% ConstraintsXXxnconstraint forall(i, j in 1..n where i < j) (XXxn    (x[i] + item_width[i] <= x[j] XXx/ x[j] + item_width[j] <= x[i]) /XXxXXxn    (y[i] + item_height[i] <= y[j] XXx/ y[j] + item_height[j] <= y[i]) /XXxXXxn    (z[i] + item_depth[i] <= z[j] XXx/ z[j] + item_depth[j] <= z[i])XXxn);XXxnXXxnconstraint forall(i in 1..n) (XXxn    x[i] + item_width[i] <= bin_width /XXxXXxn    y[i] + item_height[i] <= bin_height /XXxXXxn    z[i] + item_depth[i] <= bin_depthXXxn);XXxnXXxn% Objective: Just check if it is possible to fit all itemsXXxnsolve satisfy;XXxnXXxn% OutputXXxnoutput ['Items can fit in the bin.'];", "Class Scheduling Problem": "include 'globals.mzn';  \n  \nint: TOTAL_HOURS_PER_WEEK = 15;  \nint: DAYS_PER_WEEK = 5;  \nint: HOURS_PER_DAY = 3;  \nset of int: SUBJECTS = 1..4; % 1: A, 2: B, 3: C, 4: D  \narray[SUBJECTS, SUBJECTS] of int: session_requirements; % matrix for session requirements  \nint: n; % number of classrooms  \n  \n% Variables  \narray[1..DAYS_PER_WEEK, 1..HOURS_PER_DAY, SUBJECTS] of var 0..1: schedule; % schedule[day, hour, subject]  \narray[SUBJECTS] of var int: total_sessions; % total_sessions[subject]  \n  \n% Calculate the total sessions for each subject from the schedule  \nconstraint  \n  forall(s in SUBJECTS) (  \n    total_sessions[s] = sum([schedule[d, h, s] | d in 1..DAYS_PER_WEEK, h in 1..HOURS_PER_DAY])  \n  );  \n  \n% Ensure that the total sessions meet the requirements  \nconstraint  \n  forall(s1 in SUBJECTS, s2 in SUBJECTS where s1 != s2) (  \n    total_sessions[s1] * session_requirements[s1, s2] >= total_sessions[s2]  \n  );  \n  \n% Daily limit: no more than 3 hours of classes per day  \nconstraint  \n  forall(d in 1..DAYS_PER_WEEK) (  \n    sum([schedule[d, h, s] | h in 1..HOURS_PER_DAY, s in SUBJECTS]) <= HOURS_PER_DAY  \n  );  \n  \n% Weekly limit: no more than 15 hours of classes per week  \nconstraint  \n  sum([schedule[d, h, s] | d in 1..DAYS_PER_WEEK, h in 1..HOURS_PER_DAY, s in SUBJECTS]) <= TOTAL_HOURS_PER_WEEK;  \n  \n% Classroom constraint: at any given time, no more than 'n' classes can be scheduled  \nconstraint  \n  forall(h in 1..HOURS_PER_DAY, d in 1..DAYS_PER_WEEK) (  \n    sum([schedule[d, h, s] | s in SUBJECTS]) <= n  \n  );  \n  \n% Objective: Minimize the number of total sessions scheduled  \nvar int: total_classes = sum(s in SUBJECTS)(total_sessions[s]);  \nsolve minimize total_classes;  \n  \n% Output  \noutput ['Total Classes: ' ++ show(total_classes) ++ 'XXxn' ++  \n         concat([ 'Subject ' ++ show(s) ++ ': ' ++  \n                   concat([if schedule[d, h, s] == 1 then 'X' else '.' endif |  \n                   d in 1..DAYS_PER_WEEK, h in 1..HOURS_PER_DAY]) ++ 'XXxn' |  \n                   s in SUBJECTS]);", "3D Packing Problem": "int: width = 10;  % Width of the containerXXxnint: height = 10; % Height of the containerXXxnint: depth = 10;  % Depth of the containerXXxnXXxn% Dimensions of each item (width, height, depth)XXxnarray[1..5, 1..3] of int: item_dimensions =XXxn    array2d(1..5, 1..3, [3,3,3, 3,3,2, 4,2,3, 3,3,3, 2,3,2]);XXxnXXxn% Variables to represent the position of each item in the containerXXxnarray[1..5, 1..3] of var 0..10: position;XXxnXXxn% Constraint to ensure all items fit within the containerXXxnconstraint forall(i in 1..5) (XXxn    position[i, 1] + item_dimensions[i, 1] <= width /XXxXXxn    position[i, 2] + item_dimensions[i, 2] <= height /XXxXXxn    position[i, 3] + item_dimensions[i, 3] <= depthXXxn);XXxnXXxn% Constraint to ensure no two items overlapXXxnconstraint forall(i in 1..5, j in i+1..5) (XXxn    (position[i, 1] + item_dimensions[i, 1] <= position[j, 1] XXx/XXxn     position[j, 1] + item_dimensions[j, 1] <= position[i, 1]) XXx/XXxn    (position[i, 2] + item_dimensions[i, 2] <= position[j, 2] XXx/XXxn     position[j, 2] + item_dimensions[j, 2] <= position[i, 2]) XXx/XXxn    (position[i, 3] + item_dimensions[i, 3] <= position[j, 3] XXx/XXxn     position[j, 3] + item_dimensions[j, 3] <= position[i, 3])XXxn);XXxnXXxnsolve satisfy;XXxnXXxnoutput [XXxn    'Positions:XXxn',XXxn    'Item 1: ', show(position[1, 1]), ', ', show(position[1, 2]), ', ', show(position[1, 3]), 'XXxn',XXxn    'Item 2: ', show(position[2, 1]), ', ', show(position[2, 2]), ', ', show(position[2, 3]), 'XXxn',XXxn    'Item 3: ', show(position[3, 1]), ', ', show(position[3, 2]), ', ', show(position[3, 3]), 'XXxn',XXxn    'Item 4: ', show(position[4, 1]), ', ', show(position[4, 2]), ', ', show(position[4, 3]), 'XXxn',XXxn    'Item 5: ', show(position[5, 1]), ', ', show(position[5, 2]), ', ', show(position[5, 3]), 'XXxn'XXxn];", "Resource Allocation Problem.": "int: total_water_available; % from dzn\nint: total_land_available; % from dzn\nint: total_manure_available; % from dzn\nint: total_seeds_available; % from dzn\n\nint: crop1_yield = 2;\nint: crop1_water_req = 10;\nfloat: crop1_seeds_req = 0.1;\n\nint: crop2_yield = 3;\nint: crop2_water_req = 15;\nfloat: crop2_seeds_req = 0.2;\n\nint: crop3_yield = 4;\nint: crop3_water_req = 20;\nfloat: crop3_seeds_req = 0.15;\n\nvar 0..5000: total_water_used;\nvar 0..400: total_area_used;\nvar 0..4000: total_manure_used;\nvar 0..50: total_seeds_used;\n\nconstraint total_area_used <= 500;\nconstraint total_water_used <= 10000;\nconstraint total_manure_used <= 10000;\nconstraint total_seeds_used <= 50;\n\nconstraint total_area_used * crop1_water_req + total_area_used * crop2_water_req + total_area_used * crop3_water_req <= total_water_used;\nconstraint total_area_used * crop1_seeds_req + total_area_used * crop2_seeds_req + total_area_used * crop3_seeds_req <= total_seeds_used;\nconstraint total_area_used * 20 <= total_manure_used;\n\nconstraint crop1_yield * total_area_used >= 200;\nconstraint crop2_yield * total_area_used >= 150;\nconstraint crop3_yield * total_area_used >= 100;\n\nsolve satisfy;\n\noutput [total_water_used, total_area_used, total_manure_used, total_seeds_used];", "Ticket Sales Optimization": "```minizinc\nint: total_price_goal; % from dzn\nint: VIP_ticket_price; % from dzn\nint: regular_ticket_price; % from dzn\nint: total_expenses; % from dzn\n\nvar int: VIP_tickets_sold;\nvar int: regular_tickets_sold;\n\nvar int: total_revenue_VIP = VIP_ticket_price * VIP_tickets_sold;\nvar int: total_revenue_regular = regular_ticket_price * regular_tickets_sold;\nvar int: total_revenue = total_revenue_VIP + total_revenue_regular;\nvar int: profit = total_revenue - total_expenses;\n\nconstraint VIP_tickets_sold >= 0;\nconstraint regular_tickets_sold >= 0;\n\n% Constraints\nconstraint VIP_tickets_sold <= 200;\nconstraint regular_tickets_sold <= 1000 - 400; % Total seats minus special guest seats\n\nsolve maximize profit;\n\noutput ['Profit: ', show(profit)];\n```", "3D Packing Problem with Constraints": "int: space_x = 10;  % Dimensions of the spaces\nint: space_y = 10;\nint: space_z = 10;\n\nint: item1_x = 4;   % Dimensions of the three items\nint: item1_y = 4;\nint: item1_z = 4;\n\nint: item2_x = 4;\nint: item2_y = 2;\nint: item2_z = 2;\n\nint: item3_x = 2;\nint: item3_y = 5;\nint: item3_z = 2;\n\n% Planes where items cannot intersect\nconstraint forall(i in 1..2, j in 1..10, k in 1..10) (\n    (i == 1 /XXx j == 2) XXx/  % x = 2 plane\n    (i == 2 /XXx k == 4)      % y = 4 plane\n);\n\n% Position of each item in each space\narray[1..space_x, 1..space_y, 1..space_z] of var 0..3: space1;  % 0: empty, 1-3: item ID\narray[1..space_x, 1..space_y, 1..space_z] of var 0..3: space2;\n\nconstraint\n    % Item 1 positions\n    forall(i in 1..space_x-item1_x+1, j in 1..space_y-item1_y+1, k in 1..space_z-item1_z+1) (\n        sum(l in 0..item1_x-1, m in 0..item1_y-1, n in 0..item1_z-1)(\n            space1[i+l, j+m, k+n] != 0\n        ) == 0  % Item 1 fits in space 1\n    ) /XXx\n    forall(i in 1..space_x-item1_x+1, j in 1..space_y-item1_y+1, k in 1..space_z-item1_z+1) (\n        sum(l in 0..item1_x-1, m in 0..item1_y-1, n in 0..item1_z-1)(\n            space2[i+l, j+m, k+n] != 0\n        ) == 0  % Item 1 fits in space 2\n    ) /XXx\n    \n    % Item 2 positions\n    forall(i in 1..space_x-item2_x+1, j in 1..space_y-item2_y+1, k in 1..space_z-item2_z+1) (\n        sum(l in 0..item2_x-1, m in 0..item2_y-1, n in 0..item2_z-1)(\n            space1[i+l, j+m, k+n] != 0\n        ) == 0  % Item 2 fits in space 1\n    ) /XXx\n    forall(i in 1..space_x-item2_x+1, j in 1..space_y-item2_y+1, k in 1..space_z-item2_z+1) (\n        sum(l in 0..item2_x-1, m in 0..item2_y-1, n in 0..item2_z-1)(\n            space2[i+l, j+m, k+n] != 0\n        ) == 0  % Item 2 fits in space 2\n    ) /XXx\n\n    % Item 3 positions\n    forall(i in 1..space_x-item3_x+1, j in 1..space_y-item3_y+1, k in 1..space_z-item3_z+1) (\n        sum(l in 0..item3_x-1, m in 0..item3_y-1, n in 0..item3_z-1)(\n            space1[i+l, j+m, k+n] != 0\n        ) == 0  % Item 3 fits in space 1\n    ) /XXx\n    forall(i in 1..space_x-item3_x+1, j in 1..space_y-item3_y+1, k in 1..space_z-item3_z+1) (\n        sum(l in 0..item3_x-1, m in 0..item3_y-1, n in 0..item3_z-1)(\n            space2[i+l, j+m, k+n] != 0\n        ) == 0  % Item 3 fits in space 2\n    );\n\nsolve satisfy;\n\noutput [\n    'Space 1 layout:XXxn',\n    concat([\n        if space1[i, j, k] = 0 then '0' else show(space1[i, j, k]) endif ++ \n        if k = space_z then 'XXxn' else ' ' endif\n    | i, j, k in 1..space_x*space_y*space_z\n    ]),\n    'XXxnSpace 2 layout:XXxn',\n    concat([\n        if space2[i, j, k] = 0 then '0' else show(space2[i, j, k]) endif ++ \n        if k = space_z then 'XXxn' else ' ' endif\n    | i, j, k in 1..space_x*space_y*space_z\n    ])\n];", "Agricultural Resource Allocation Problem": "int: total_water; % from dznXXxnint: total_land; % from dznXXxnint: total_manure; % from dznXXxnint: total_seeds; % from dznXXxnXXxn% Crop typesXXxnint: A; % Crop AXXxnint: B; % Crop BXXxnint: C; % Crop CXXxnXXxn% Yield per square meter for each crop (in kg)XXxnfloat: yield_A = 3.0;XXxnfloat: yield_B = 2.0;XXxnfloat: yield_C = 1.5;XXxnXXxn% Resource requirements per square meter for each cropXXxnfloat: water_per_sqm = 100.0;XXxnfloat: seeds_per_sqm_A = 0.01;XXxnfloat: seeds_per_sqm_B = 0.015;XXxnfloat: seeds_per_sqm_C = 0.02;XXxnXXxn% Target weights for each crop (in kg)XXxnint: target_A = 300;XXxnint: target_B = 200;XXxnint: target_C = 150;XXxnXXxn% Decision variables: area (in square meters) allocated to each cropXXxnvar 0..total_land: area_A;XXxnvar 0..total_land: area_B;XXxnvar 0..total_land: area_C;XXxnXXxn% ConstraintsXXxnconstraintXXxn    % Resource constraintsXXxn    area_A * water_per_sqm + area_B * water_per_sqm + area_C * water_per_sqm <= total_water /XXxXXxn    area_A + area_B + area_C <= total_land /XXxXXxn    area_A * 20 + area_B * 20 + area_C * 20 <= total_manure /XXxXXxn    area_A * seeds_per_sqm_A + area_B * seeds_per_sqm_B + area_C * seeds_per_sqm_C <= total_seeds /XXxXXxnXXxn    % Yield constraintsXXxn    area_A * yield_A >= target_A /XXxXXxn    area_B * yield_B >= target_B /XXxXXxn    area_C * yield_C >= target_C;XXxnXXxn% Objective: Maximize the total yieldXXxnvar float: total_yield = area_A * yield_A + area_B * yield_B + area_C * yield_C;XXxnsolve maximize total_yield;XXxnXXxnoutput [XXxn    'Area allocated to Crop A: ', show(area_A), 'XXxn',XXxn    'Area allocated to Crop B: ', show(area_B), 'XXxn',XXxn    'Area allocated to Crop C: ', show(area_C), 'XXxn',XXxn    'Total Yield: ', show(total_yield), 'XXxn'XXxn];", "Solar Panel Cost-Benefit Analysis": "% Parameters\nint: cost_solar_panels; % from dzn\nint: electricity_generation; % from dzn\nint: cost_purchased_electricity; % from dzn\nint: electricity_demand; % from dzn\nint: budget = 5000;\n\n% Variables\nvar int: total_cost = cost_solar_panels + (electricity_demand div electricity_generation) * cost_purchased_electricity;\nvar int: total_electricity_output = electricity_generation + electricity_demand;\n\n% Constraints\nconstraint total_cost <= budget /XXx total_electricity_output >= 4000;\n\n% Objective: Minimize the total cost\nsolve satisfy;\n\n% Output\noutput['Total Cost: XXx(total_cost)XXxn'];\noutput['Total Electricity Output: XXx(total_electricity_output)XXxn'];", "Furniture Placement Problem": "include 'globals.mzn';XXxnXXxn% Number of furniture piecesXXxnint: num_furniture;XXxnXXxn% Grid dimensions (n x n)XXxnint: n;XXxnXXxn% Compatibility matrixXXxnarray[1..num_furniture, 1..num_furniture] of int: compatibility;XXxnXXxn% Variables: grid[i, j] is the furniture piece at position (i, j), or 0 if emptyXXxnarray[1..n, 1..n] of var 0..num_furniture: grid;XXxnXXxn% Constraint 1: No two pieces can occupy the same positionXXxnconstraintXXxn  forall(f1 in 1..num_furniture, f2 in f1+1..num_furniture) (XXxn    (exists(i, j in 1..n)(grid[i, j] = f1) /XXx exists(i, j in 1..n)(grid[i, j] = f2)) ->XXxn    compatibility[f1, f2] != 0XXxn  );XXxnXXxn% Constraint 2: Adjacency rules based on the compatibility matrixXXxnconstraintXXxn  forall(i in 1..n, j in 1..n, f1 in 1..num_furniture, f2 in f1+1..num_furniture where grid[i, j] = f1 /XXx compatibility[f1, f2] != 1)(XXxn    (j > 1 /XXx grid[i, j-1] = f2) XXx/  % LeftXXxn    (j < n /XXx grid[i, j+1] = f2) XXx/  % RightXXxn    (i > 1 /XXx grid[i-1, j] = f2) XXx/  % UpXXxn    (i < n /XXx grid[i+1, j] = f2)     % DownXXxn  );XXxnXXxn% Solve the problem by filling the gridXXxnsolve satisfy;XXxnXXxn% Output the gridXXxnoutput [XXxn  concat([concat([show(grid[i, j]) ++ ' ' | j in 1..n]) ++ 'XXxn' | i in 1..n])XXxn];", "ticket_sales_revenue": "int: VIP_price = 170; % Price per VIP seat\nint: Regular_price = 60; % Price per regular seat\nint: VIP_capacity = 200; % Total number of VIP seats available\nint: Regular_capacity = 800; % Total number of regular seats available\nint: Total_capacity = 1000; % Total number of seats available\nint: Goal_revenue = 50000; % Target revenue\nint: VIP_cost = 30000; % Cost for VIP seats\nint: Regular_cost = 48000; % Cost for regular seats\n\nvar 0..VIP_capacity: VIP_sold; % Number of VIP seats sold\nvar 0..Regular_capacity: Regular_sold; % Number of regular seats sold\n\n% Objective: Maximize profit (total revenue - total cost)\nvar int: Revenue = VIP_sold * VIP_price + Regular_sold * Regular_price;\nvar int: Cost = VIP_cost + Regular_cost;\nvar int: Profit = Revenue - Cost;\n\n% Constraints\nconstraint VIP_sold + Regular_sold <= Total_capacity; % Total seats sold cannot exceed available seats\n\nconstraint Revenue >= Goal_revenue; % Total revenue must meet or exceed the goal\nconstraint Profit >= 0; % Ensure profit covers expenses\n\nsolve maximize Profit;\n\noutput ['VIP seats sold: XXx(VIP_sold)XXxn',\n        'Regular seats sold: XXx(Regular_sold)XXxn',\n        'Total revenue: XXx(Revenue)XXxn',\n        'Total cost: XXx(Cost)XXxn',\n        'Profit: XXx(Profit)XXxn'];", "BOARD1_LBOARD1_ODD_BOARD3_EVEN_BOARD2_LBOARD2_SPECIAL": "% Parameters\nint: BOARD1; % from dzn\nint: LBOARD1; % from dzn\nint: BOARD3; % from dzn\nint: BOARD2; % from dzn\nint: LBOARD2; % from dzn\n\n% Variables\narray[1..BOARD1] of var 0..1: board1;\narray[1..LBOARD1] of var 0..1: lboard1;\narray[1..BOARD3] of var 0..1: board3;\narray[1..BOARD2] of var 0..1: board2;\narray[1..LBOARD2] of var 0..1: lboard2;\n\n% Constraints\nconstraint forall(i in 1..BOARD1)(board1[i] in 0..1);\nconstraint forall(i in 1..LBOARD1)(lboard1[i] in 0..1);\nconstraint forall(i in 1..BOARD3)(board3[i] in 0..1);\nconstraint forall(i in 1..BOARD2)(board2[i] in 0..1);\nconstraint forall(i in 1..LBOARD2)(lboard2[i] in 0..1);\n\nconstraint sum(board1) == sum(lboard1) /XXx\n            sum(board3) == 0 /XXx\n            sum(lboard2) == 1 /XXx\n            sum(board2) == 1;\n\nsolve satisfy;\n\noutput [\n  'Board1: ' ++ show(board1) ++ 'XXxn' ++\n  'LBoard1: ' ++ show(lboard1) ++ 'XXxn' ++\n  'Board3: ' ++ show(board3) ++ 'XXxn' ++\n  'Board2: ' ++ show(board2) ++ 'XXxn' ++\n  'LBoard2: ' ++ show(lboard2)\n];", "2D non-overlapping placement with non-touching constraints": "% Number of items\nint: num_items;\n\n% Size of the space\narray[1..2] of int: space;\n\n% Size of each item\narray[1..num_items, 1..2] of int: item_sizes;\n\n% Non-touching constraints\narray[1..num_items, 1..num_items] of int: non_touching_constraints;\n\n% Decision variables: coordinates of the top-left corner of each item\narray[1..num_items, 1..2] of var 0..max(space): placement;\n\n% Constraints to ensure items fit in the space\nconstraint\n    forall(i in 1..num_items)(\n        placement[i, 1] + item_sizes[i, 1] <= space[1] /XXx\n        placement[i, 2] + item_sizes[i, 2] <= space[2]\n    );\n\n% Constraints to avoid overlapping\nconstraint\n    forall(i, j in 1..num_items where i < j)(\n        (placement[i, 1] + item_sizes[i, 1] <= placement[j, 1] XXx/\n         placement[j, 1] + item_sizes[j, 1] <= placement[i, 1]) XXx/\n        (placement[i, 2] + item_sizes[i, 2] <= placement[j, 2] XXx/\n         placement[j, 2] + item_sizes[j, 2] <= placement[i, 2])\n    );\n\n% Constraint to enforce non-touching constraints\nconstraint\n    forall(i, j in 1..num_items where i < j)(\n        non_touching_constraints[i, j] = 0 XXx/\n        (abs(placement[i, 1] - placement[j, 1]) >= 2 XXx/\n         abs(placement[i, 2] - placement[j, 2]) >= 2)\n    );\n\n% Objective: minimize the total area used\nvar int: total_area = max(space) * max(space);\nsolve minimize total_area;\n\n% Output\noutput ['Total area used: ' ++ show(total_area) ++ 'XXxn'];\noutput ['Coordinates of top-left corners of items:XXxn'];\noutput [\n    '(' ++ show(placement[i, 1]) ++ ', ' ++ show(placement[i, 2]) ++ ')XXxn'\n    | i in 1..num_items\n];", "3D Packing Problem with Restricted Placement": "% from dzn\n\nint: space_x = 10; \nint: space_y = 10; \nint: space_z = 10; \n\narray[1..3, 1..3] of int: item_dims = array2d(1..3, 1..3, [4, 4, 4, 4, 2, 2, 2, 5, 2]); \n\n% Restricting planes \nconstraint forall(i in 1..3) (\n    item_dims[i, 1] != 2 % x = 2\n    /XXx item_dims[i, 2] != 4 % y = 4\n); \n\n% Ensure items fit into the space \nconstraint forall(i in 1..3) (\n    item_dims[i, 1] <= space_x\n    /XXx item_dims[i, 2] <= space_y\n    /XXx item_dims[i, 3] <= space_z\n); \n\n% The item cannot be placed in the same position \n% If two items have the same position, then the sum of any two dimensions of the same axis must be less than or equal to the dimension of the space. \n% This is because the sum of the dimensions of the two items in the same axis will be added to the same position of the space. \narray[1..3] of var 0..space_x: x; \narray[1..3] of var 0..space_y: y; \narray[1..3] of var 0..space_z: z; \n\nconstraint forall(i, j in 1..3 where i != j) (\n    (x[i] == x[j] -> item_dims[i, 1] + item_dims[j, 1] <= space_x) /XXx\n    (y[i] == y[j] -> item_dims[i, 2] + item_dims[j, 2] <= space_y) /XXx\n    (z[i] == z[j] -> item_dims[i, 3] + item_dims[j, 3] <= space_z)\n); \n\nsolve satisfy; \n\noutput ['Item 1: (x=', show(x[1]), ', y=', show(y[1]), ', z=', show(z[1]), ') ',\n        'Item 2: (x=', show(x[2]), ', y=', show(y[2]), ', z=', show(z[2]), ') ',\n        'Item 3: (x=', show(x[3]), ', y=', show(y[3]), ', z=', show(z[3]), ') '];", "Precision_Ag_Field_Management": "int: water_usage; % amount of water used for irrigation per hectare (in liters)XXxnint: fertilizer_usage; % amount of fertilizer used per hectare (in kg)XXxnint: pesticide_usage; % amount of pesticide used per hectare (in liters)XXxnXXxnint: water_limit = 100000; % maximum amount of water available for irrigation (in liters)XXxnint: fertilizer_limit = 100; % maximum amount of fertilizer available (in kg)XXxnint: pesticide_limit = 10; % maximum amount of pesticide available (in liters)XXxnXXxnint: corn_weight_target = 8000; % target weight of corn produced per hectare (in kg)XXxnint: soybean_weight_target = 6000; % target weight of soybeans produced per hectare (in kg)XXxnXXxnvar 0..1: corn_planting; % boolean variable for planting corn (1 if true, 0 if false)XXxnvar 0..1: soybean_planting; % boolean variable for planting soybeans (1 if true, 0 if false)XXxnXXxn% Constraints on resource usageXXxnconstraint water_usage * corn_planting + water_usage * soybean_planting <= water_limit;XXxnconstraint fertilizer_usage * corn_planting + fertilizer_usage * soybean_planting <= fertilizer_limit;XXxnconstraint pesticide_usage * corn_planting + pesticide_usage * soybean_planting <= pesticide_limit;XXxnXXxn% Crop weight requirementsXXxnconstraint corn_weight_target * corn_planting + soybean_weight_target * soybean_planting >= corn_weight_target;XXxnconstraint corn_weight_target * corn_planting + soybean_weight_target * soybean_planting >= soybean_weight_target;XXxnXXxnsolve satisfy;XXxnXXxnoutput [XXxn    'Plant corn: ', show(corn_planting), 'XXxn',XXxn    'Plant soybeans: ', show(soybean_planting), 'XXxn'XXxn];", "furniture_arrangement_compatibility": "include 'globals.mzn';XXxnXXxn% ParametersXXxnint: n = 3; % Grid sizeXXxnset of int: POSITIONS = 1..n*n; % Positions in the gridXXxnXXxn% Furniture piecesXXxnint: num_pieces = 9; % Number of pieces (A, B, C, D, E, F, G, H, I)XXxnarray[1..num_pieces] of var POSITIONS: piece_positions; % Position of each piece in the gridXXxnarray[1..num_pieces, 1..num_pieces] of int: compatibility; % Compatibility matrixXXxnXXxn% ConstraintsXXxnXXxn% Constraint 1: Each piece must occupy a different positionXXxnconstraint alldifferent(piece_positions);XXxnXXxn% Constraint 2: Incompatible pieces cannot be adjacentXXxnconstraint forall(p1 in 1..num_pieces, p2 in 1..num_pieces where p1 != p2) (XXxn    abs(piece_positions[p1] div n - piece_positions[p2] div n) +XXxn    abs(piece_positions[p1] mod n - piece_positions[p2] mod n) > 1 XXx/ compatibility[p1, p2] = 0XXxn);XXxnXXxnsolve satisfy;XXxnXXxn% OutputXXxnarray[1..n, 1..n] of var 1..num_pieces: grid;XXxnXXxnconstraintXXxn    forall(i in 1..n, j in 1..n) (XXxn        grid[i, j] = piece_positions[(i-1)*n + j]XXxn    );XXxnXXxnoutput [XXxn    'Solution:XXxn',XXxn    concat([show(grid[i, j]) ++ if j == n then 'XXxn' else ' ' endif | i, j in 1..n])XXxn];", "Furniture Arrangement Problem": "int: num_furniture_pieces; % Number of furniture piecesXXxnint: room_width; % Width of the roomXXxnint: room_height; % Height of the roomXXxnXXxn% Compatibility matrixXXxnarray[1..num_furniture_pieces, 1..num_furniture_pieces] of int: compatibility_matrix;XXxnXXxn% Position of each furniture piece in the roomXXxnarray[1..num_furniture_pieces] of var 1..room_width: x;XXxnarray[1..num_furniture_pieces] of var 1..room_height: y;XXxnXXxn% Constraint 1: Furniture must be within the room dimensionsXXxnconstraint forall(i in 1..num_furniture_pieces) (XXxn    x[i] >= 1 /XXx x[i] <= room_width /XXxXXxn    y[i] >= 1 /XXx y[i] <= room_heightXXxn);XXxnXXxn% Constraint 2: Incompatible furniture must not be adjacent (including diagonally)XXxnconstraint forall(i in 1..num_furniture_pieces, j in i+1..num_furniture_pieces where compatibility_matrix[i,j] == 0) (XXxn    abs(x[i] - x[j]) > 1 XXx/ abs(y[i] - y[j]) > 1XXxn);XXxnXXxnsolve satisfy;XXxnXXxn% Output the positions of each furniture pieceXXxnoutput ['Furniture positions: ' ++ show(x) ++ 'XXxn' ++ show(y)];", "Event Seating and Revenue Optimization": "% Parameters\nint: total_seats; % from dzn\nint: max_VIP_seats = 200;\nint: max_free_seats = 400;\nint: total_price_goal;\nint: VIP_price = 50;\nint: regular_price = 20;\nint: VIP_special_guest_seats = 10;\nint: expenses = 1000;\n\n% Variables\nvar 0..max_VIP_seats: VIP_tickets_sold;\nvar 0..total_seats - VIP_special_guest_seats: regular_tickets_sold; \n\n% Objective: Maximize profit (revenue - expenses)\nvar int: revenue = VIP_tickets_sold * VIP_price + regular_tickets_sold * regular_price;\nvar int: profit = revenue - expenses;\n\n% Constraints\nconstraint VIP_tickets_sold + VIP_special_guest_seats <= max_VIP_seats; % VIP seats constraint\nconstraint regular_tickets_sold <= total_seats - VIP_tickets_sold - VIP_special_guest_seats; % Free seats constraint\nconstraint revenue >= total_price_goal; % Ensure the total price goal is met\n\nsolve maximize profit;\n\noutput ['VIP tickets sold: ', show(VIP_tickets_sold), 'XXxn',\n        'Regular tickets sold: ', show(regular_tickets_sold), 'XXxn',\n        'Total Revenue: ', show(revenue), 'XXxn',\n        'Total Profit: ', show(profit), 'XXxn'];", "Board Assignment Problem": "% Variables\nint: n;  % Number of board types (from dzn)\nint: m;  % Number of available slots (from dzn)\n\n% List of dictionaries to define each board type's quantity and slot requirements\narray[1..n] of var int: quantity;\narray[1..n] of var int: slots_required;\n\n% Constraints\nconstraint sum(i in 1..n)(quantity[i] * slots_required[i]) <= m;  % Total slots used by all boards must not exceed m\n\n% Objective: Maximize the total number of boards used\nvar int: total_boards = sum(i in 1..n)(quantity[i]);\nsolve maximize total_boards;\n\noutput ['Total boards used: ' ++ show(total_boards)];", "3D Packing with Constraints": "int: n;  % Number of items\nint: width_space;  % Width of the 3D space\nint: height_space; % Height of the 3D space\nint: depth_space;  % Depth of the 3D space\n\narray[1..n] of int: width_item;  % Width of each item\narray[1..n] of int: height_item; % Height of each item\narray[1..n] of int: depth_item;  % Depth of each item\n\n% Touching constraints: 1 means the two items cannot touch, 0 means they can touch\narray[1..n, 1..n] of int: touching; \n\n% Decision variable: item_position[i] is the position of item i\narray[1..n] of var 0..width_space: x_item; % X-coordinate in the space\narray[1..n] of var 0..height_space: y_item; % Y-coordinate in the space\narray[1..n] of var 0..depth_space: z_item;  % Z-coordinate in the space\n\n% Constraint to not intersect within the same space\nconstraint\n  forall(i, j in 1..n where i < j) (\n    x_item[i] + width_item[i] <= x_item[j] XXx/\n    x_item[j] + width_item[j] <= x_item[i] XXx/\n    y_item[i] + height_item[i] <= y_item[j] XXx/\n    y_item[j] + height_item[j] <= y_item[i] XXx/\n    z_item[i] + depth_item[i] <= z_item[j] XXx/\n    z_item[j] + depth_item[j] <= z_item[i]\n  );\n\n% Constraint based on the touching matrix\nconstraint\n  forall(i, j in 1..n where i < j) (\n    touching[i, j] = 1 -> (\n      x_item[i] + width_item[i] <= x_item[j] XXx/\n      x_item[j] + width_item[j] <= x_item[i] XXx/\n      y_item[i] + height_item[i] <= y_item[j] XXx/\n      y_item[j] + height_item[j] <= y_item[i] XXx/\n      z_item[i] + depth_item[i] <= z_item[j] XXx/\n      z_item[j] + depth_item[j] <= z_item[i]\n    )\n  );\n\nsolve satisfy;\n\noutput ['Items placement:XXxn'] ++ \n       [show(i) ++ ': (' ++ show(x_item[i]) ++ ', ' ++ show(y_item[i]) ++ ', ' ++ show(z_item[i]) ++ ')XXxn' | i in 1..n];", "Precision Agriculture Field Management": "% Precision Agriculture Field Management Problem\n% Given the available resources, crop requirements, and constraints, we aim to maximize the total crop weight harvested.\n\n% Parameters\nint: land_area;            % Total land area available (in square meters)\nint: water_available;      % Total water available (in liters)\nint: manure_available;     % Total manure available (in kilograms)\nint: seed_available;        % Total seed available (in kilograms)\n\n% Crop requirements per square meter\nint: water_req_wheat = 3;   % Water required per square meter for wheat (in liters)\nint: water_req_corn = 5;    % Water required per square meter for corn (in liters)\nint: water_req_soybean = 4; % Water required per square meter for soybean (in liters)\n\nint: seed_req_wheat = 2;    % Seed required per square meter for wheat (in kilograms)\nint: seed_req_corn = 3;     % Seed required per square meter for corn (in kilograms)\nint: seed_req_soybean = 1;  % Seed required per square meter for soybean (in kilograms)\n\nint: manure_req_wheat = 1;  % Manure required per square meter for wheat (in kilograms)\nint: manure_req_corn = 2;   % Manure required per square meter for corn (in kilograms)\nint: manure_req_soybean = 1; % Manure required per square meter for soybean (in kilograms)\n\n% Required weights for each crop type\nint: wheat_weight = 10;     % Required weight of wheat per square meter (in kilograms)\nint: corn_weight = 20;      % Required weight of corn per square meter (in kilograms)\nint: soybean_weight = 15;   % Required weight of soybean per square meter (in kilograms)\n\n% Decision variables: hectares of each crop type\nvar 0..land_area: wheat_hectares;   % Area allocated to wheat (in square meters)\nvar 0..land_area: corn_hectares;    % Area allocated to corn (in square meters)\nvar 0..land_area: soybean_hectares; % Area allocated to soybean (in square meters)\n\n% Constraints\nconstraint\n  wheat_hectares + corn_hectares + soybean_hectares <= land_area /XXx\n  wheat_hectares * water_req_wheat + corn_hectares * water_req_corn + soybean_hectares * water_req_soybean <= water_available /XXx\n  wheat_hectares * seed_req_wheat + corn_hectares * seed_req_corn + soybean_hectares * seed_req_soybean <= seed_available /XXx\n  wheat_hectares * manure_req_wheat + corn_hectares * manure_req_corn + soybean_hectares * manure_req_soybean <= manure_available /XXx\n  wheat_hectares * wheat_weight + corn_hectares * corn_weight + soybean_hectares * soybean_weight >= wheat_weight * wheat_hectares + corn_weight * corn_hectares + soybean_weight * soybean_hectares;\n\n% Objective: Maximize the total weight of all crops harvested\nsolve maximize wheat_hectares * wheat_weight + corn_hectares * corn_weight + soybean_hectares * soybean_weight;\n\n% Output\noutput ['Wheat hectares: ', show(wheat_hectares), 'XXxn',\n        'Corn hectares: ', show(corn_hectares), 'XXxn',\n        'Soybean hectares: ', show(soybean_hectares), 'XXxn',\n        'Total weight harvested: ', show(wheat_hectares * wheat_weight + corn_hectares * corn_weight + soybean_hectares * soybean_weight), ' kgXXxn'];", "Board Placement Problem": "% Parameters\nint: n; % from dzn\nint: m; % from dzn\n\n% Quantities of each board type\narray[1..n] of var 0..m: quantities; % from dzn\n\n% Slot requirements for each board type\narray[1..n] of var 1..2: slots; % from dzn\narray[1..n] of var -1..m: odd; % from dzn\narray[1..n] of var 0..m: powers_of_2; % from dzn\n\n% Constraints for slot requirements\nconstraint forall(i in 1..n)(\n    (odd[i] = -1 XXx/ odd[i] mod 2 = 1) /XXx\n    (powers_of_2[i] = 0 XXx/ (powers_of_2[i] != 0 /XXx powers_of_2[i] mod 2 = 0))\n);\n\n% LBOARD constraint\nconstraint (sum(i in 1..n)(quantities[i]) >= 5) -> (quantities[1] + quantities[2] >= 2);\n\n% Objective: Maximize the total number of boards placed\nvar int: total_boards = sum(i in 1..n)(quantities[i]);\n\nsolve maximize total_boards;\n\noutput ['Total boards placed: ', show(total_boards), 'XXxn'];\n", "Three-Dimensional Packing Problem": "% Place items with given dimensions in the bin of a given size, without overlapping,\n% while respecting the list of item pairs that are not allowed to touch each other.\n% Each item pair in the list cannot be adjacent in any of the three dimensions (width, height, depth).\n\ninclude 'globals.mzn'; \nint: n = 3; % Number of items (from dzn)\nint: bin_width = 10; % Bin width (from dzn)\nint: bin_height = 10; % Bin height (from dzn)\nint: bin_depth = 10; % Bin depth (from dzn)\narray[1..n, 1..3] of int: items = array2d(1..n, 1..3, [2, 1, 2, 1, 1, 1, 2, 2, 1]); % Item dimensions (from dzn)\narray[1..16] of int: not_adjacent = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]; % Forbidden pairs (from dzn)\n\n% Variables to represent the (x, y, z) coordinates of each item\narray[1..n, 1..3] of var 0..bin_width: item_x;\narray[1..n, 1..3] of var 0..bin_height: item_y;\narray[1..n, 1..3] of var 0..bin_depth: item_z;\n\n% Constraint: Items must fit in the bin\nconstraint forall(i in 1..n, j in 1..3)(\n    item_x[i, j] + items[i, j] <= bin_width /XXx\n    item_y[i, j] + items[i, j] <= bin_height /XXx\n    item_z[i, j] + items[i, j] <= bin_depth\n);\n\n% Constraint: No two items overlap\nconstraint\n    forall(i, j in 1..n where i < j)(\n        (item_x[i, 1] + items[i, 1] <= item_x[j, 1] XXx/ item_x[j, 1] + items[j, 1] <= item_x[i, 1]) /XXx\n        (item_y[i, 2] + items[i, 2] <= item_y[j, 2] XXx/ item_y[j, 2] + items[j, 2] <= item_y[i, 2]) /XXx\n        (item_z[i, 3] + items[i, 3] <= item_z[j, 3] XXx/ item_z[j, 3] + items[j, 3] <= item_z[i, 3])\n    );\n\n% Constraint: Forbidden pairs should not be adjacent\nconstraint\n    forall(i in 1..n, j in 1..n where i != j, k in 1..16)(\n        (not_adjacent[k] != i /XXx not_adjacent[k] != j)\n        XXx/ (abs(item_x[i, 1] - item_x[j, 1]) > 1 XXx/ abs(item_y[i, 2] - item_y[j, 2]) > 1 XXx/ abs(item_z[i, 3] - item_z[j, 3]) > 1)\n    );\n\nsolve satisfy;\n\noutput [\n    'Placement results:XXxn'\n] ++\n[\n    'Item ' ++ show(i) ++ ': (' ++ show(item_x[i, 1]) ++ ', ' ++ show(item_y[i, 2]) ++ ', ' ++ show(item_z[i, 3]) ++ ')XXxn'\n    | i in 1..n\n];", "3D Packing Problem.": "% Parameters\nint: n; % Number of items\nint: m; % Number of spaces\n\n% Dimensions of the spaces\narray[1..m] of int: width;\narray[1..m] of int: height;\narray[1..m] of int: depth;\n\n% Specific geometric planes\nint: plane1; % Plane along x-axis\nint: plane2; % Plane along y-axis\nint: plane3; % Plane along z-axis\n\n% Item coordinates and dimensions\narray[1..n] of int: x; % X-coordinate of bottom-left-back corner\narray[1..n] of int: y; % Y-coordinate of bottom-left-back corner\narray[1..n] of int: z; % Z-coordinate of bottom-left-back corner\narray[1..n] of int: w; % Width of the item\narray[1..n] of int: h; % Height of the item\narray[1..n] of int: d; % Depth of the item\n\n% Decision variables: Assign item i to space j\narray[1..n] of var 1..m: space;\n\n% Constraint 1: Items must not intersect within a space or across spaces\nconstraint\n    forall(i, j in 1..n where i < j /XXx space[i] = space[j]) (\n        % Check if items i and j intersect\n        not (\n            (x[i] + w[i] <= x[j] XXx/ x[j] + w[j] <= x[i]) XXx/\n            (y[i] + h[i] <= y[j] XXx/ y[j] + h[j] <= y[i]) XXx/\n            (z[i] + d[i] <= z[j] XXx/ z[j] + d[j] <= z[i])\n        )\n    );\n\n% Constraint 2: Items must not intersect with specific geometric planes\nconstraint\n    forall(i in 1..n) (\n        x[i] >= plane1 /XXx x[i] + w[i] <= plane2 /XXx\n        y[i] >= plane1 /XXx y[i] + h[i] <= plane2 /XXx\n        z[i] >= plane1 /XXx z[i] + d[i] <= plane2\n    );\n\n% Constraint 3: Items must fit within the dimensions of the spaces\nconstraint\n    forall(i in 1..n) (\n        x[i] >= 0 /XXx x[i] + w[i] <= width[space[i]] /XXx\n        y[i] >= 0 /XXx y[i] + h[i] <= height[space[i]] /XXx\n        z[i] >= 0 /XXx z[i] + d[i] <= depth[space[i]]\n    );\n\n% Objective: Minimize the number of used spaces\nvar int: used_spaces = max(space);\nsolve minimize used_spaces;\n\n% Output the item-space assignments\noutput['Items are placed in the following spaces:XXxn'];\noutput['Space assignments: '];\noutput(array1d(1..n, space) ++ ['XXxn']);", "Grid Adjacency Constraint Satisfaction Problem": "int: n = 3; % Grid size (n x n)XXxnXXxn% Define the types of furniture piecesXXxnset of int: Furniture = 1..3;  % 1=A, 2=B, 3=CXXxnXXxn% Compatibility matrixXXxnarray[Furniture, Furniture] of int: compatibility = array2d(Furniture, Furniture, [1, 1, 1, 1, 1, 1, 1, 1, 1]);  % 0=no, 1=maybe, 2=yesXXxnXXxn% Decision variablesXXxnarray[1..n, 1..n] of var Furniture: grid;XXxnXXxn% Adjacency rules (above, below, left, right)XXxnconstraint forall(i in 1..n, j in 1..n where i > 1) (XXxn    if compatibility[grid[i,j], grid[i-1,j]] == 0 thenXXxn        falseXXxn    elseXXxn        trueXXxn    endifXXxn);XXxnXXxnconstraint forall(i in 1..n, j in 1..n where i < n) (XXxn    if compatibility[grid[i,j], grid[i+1,j]] == 0 thenXXxn        falseXXxn    elseXXxn        trueXXxn    endifXXxn);XXxnXXxnconstraint forall(i in 1..n, j in 1..n where j > 1) (XXxn    if compatibility[grid[i,j], grid[i,j-1]] == 0 thenXXxn        falseXXxn    elseXXxn        trueXXxn    endifXXxn);XXxnXXxnconstraint forall(i in 1..n, j in 1..n where j < n) (XXxn    if compatibility[grid[i,j], grid[i,j+1]] == 0 thenXXxn        falseXXxn    elseXXxn        trueXXxn    endifXXxn);XXxnXXxn% No two furniture pieces can occupy the same positionXXxnconstraint forall(i in 1..n, j in 1..n, i2 in 1..n, j2 in 1..n where i != i2 XXx/ j != j2) (XXxn    if grid[i,j] == grid[i2,j2] thenXXxn        falseXXxn    elseXXxn        trueXXxn    endifXXxn);XXxnXXxnsolve satisfy;XXxnXXxn% Output the gridXXxnoutput [XXxn    'Furniture layout:XXxn'XXxn] ++XXxn[XXxn    if j == n then show_int(grid[i,j]) ++ 'XXxn' else show_int(grid[i,j]) ++ ' ' endifXXxn    | i, j in 1..nXXxn];", "Concert Ticket Sales Optimization": "int: VIP_Price = 170;  % Price of a VIP ticket\nint: Regular_Price = 60;  % Price of a regular ticket\nint: Total_Price_Goal = 50000;  % Total revenue goal\nint: Total_Seats = 1000;  % Total available seats\nint: VIP_Seats = 200;  % Seats reserved for VIP tickets\nint: Free_Seats = 400;  % Free seats\nint: Special_Guest_Seats = 400;  % Seats reserved for special guests\n\nint: Expenses = 45000;  % Fixed expenses\n\n% Decision variables\nvar 0..VIP_Seats: VIP_Tickets;  % Number of VIP tickets to sell\nvar 0..(Total_Seats - VIP_Seats - Free_Seats): Regular_Tickets;  % Number of regular tickets to sell\n\n% Revenue calculation\nvar int: Revenue = VIP_Price * VIP_Tickets + Regular_Price * Regular_Tickets;\n\n% Objective: Maximize profit (Profit = Revenue - Expenses)\nvar int: Profit = Revenue - Expenses;\n\n% Constraints\nconstraint Revenue >= Total_Price_Goal;  % Meet revenue goal\nconstraint VIP_Tickets <= VIP_Seats;  % Respect available VIP seats\nconstraint Regular_Tickets + VIP_Tickets <= Total_Seats - Free_Seats;  % Respect total available seats\n\nsolve maximize Profit;\n\noutput ['VIP Tickets: XXx(VIP_Tickets)XXxnRegular Tickets: XXx(Regular_Tickets)XXxnTotal Revenue: XXx(Revenue)XXxnProfit: XXx(Profit)'];", "Class Schedule Optimization": "int: n;  % number of classroomsXXxnint: m;  % maximum hours per day per classroomXXxnXXxn% ConstantsXXxnint: hours_per_day = 3;  % School operates for 3 hours each dayXXxnint: hours_per_week = 15;  % School operates 5 days a weekXXxnint: total_hours_per_subject_per_week = 3;  % Each subject requires 3 hours per weekXXxnint: hours_per_subject_per_day = total_hours_per_subject_per_week div 5;  % Each subject requires 3/5 = 0.6 hours per dayXXxnXXxnint: k;  % number of classesXXxnint: p;  % number of subjectsXXxnint: z;  % maximum number of subjects per class per weekXXxnXXxn% Decision variablesXXxnarray[1..k, 1..p] of var 0..1: has_subject;  % has_subject[i, j] = 1 if class i has subject jXXxnXXxn% ConstraintsXXxnXXxn% Each class has between 1 and z subjects per weekXXxnconstraint forall(i in 1..k)(sum(j in 1..p)(has_subject[i, j]) >= 1 /XXx sum(j in 1..p)(has_subject[i, j]) <= z);XXxnXXxn% Ensure that the weekly schedule is balanced across all five daysXXxnconstraint forall(j in 1..p)(XXxn    sum(i in 1..k)(has_subject[i, j] * hours_per_subject_per_day) <= hours_per_weekXXxn);XXxnXXxn% Objective: Minimize the difference in hours spent on each subjectXXxnvar int: objective = sum(j in 1..p)(XXxn    abs(sum(i in 1..k)(has_subject[i, j] * hours_per_subject_per_day)) - hours_per_weekXXxn);XXxnXXxnsolve minimize objective;XXxnXXxnoutput [XXxn  'Schedule: XXxn',XXxn  '------------------------------------------------------XXxn'XXxn] ++XXxn[XXxn  if j == 1 then 'XXxnSubject ' ++ show(j) ++ ': ' else '' endif ++XXxn  if j < 10 then ' ' else '' endif ++XXxn  if has_subject[i, j] = 1 then 'Class ' ++ show(i) ++ ' ' else '        ' endifXXxn  | i in 1..k, j in 1..pXXxn] ++XXxn['XXxn------------------------------------------------------'XXxn];", "3D Packing with Obstacles": "% Parameters\nint: num_items; % from dzn\nint: num_spaces; % from dzn\n\n% Decision variables\narray[1..num_items, 1..3] of var 1..num_spaces: item_placement; % Which space each item is placed in\n\n% Geometric constraints - specified planes that cannot be intersected\nconstraint\n    forall(i in 1..num_items, j in 1..num_items where i < j)(\n        item_placement[i, 1] != item_placement[j, 1] /XXx\n        item_placement[i, 2] != item_placement[j, 2] /XXx\n        item_placement[i, 3] != item_placement[j, 3]\n    );\n\n% Solve and output\nsolve satisfy;\n\noutput [\n    'Item ' ++ show(i) ++ ' is in space (' ++ show(item_placement[i, 1]) ++ ', ' ++\n    show(item_placement[i, 2]) ++ ', ' ++ show(item_placement[i, 3]) ++ ')XXxn'\n    | i in 1..num_items\n];", "Home Electricity Management": "int: cost_per_panel; % from dzn\nint: electricity_per_panel; % from dzn\nint: cost_per_kWh; % from dzn\nint: yearly_demand; % from dzn\n\n% Decision variable: Number of solar panels to purchase\nvar 0..10: num_panels;\n\n% Cost calculation\nvar 0..5000: total_cost = num_panels * cost_per_panel;\nvar 0..5000: remaining_budget = 5000 - total_cost;\n\n% Electricity generation and additional purchase calculation\nvar 0..10000: total_generation = num_panels * electricity_per_panel;\nvar 0..10000: additional_purchase = max(0, yearly_demand - total_generation);\n\nvar 0..5000: cost_of_purchase = additional_purchase * cost_per_kWh;\n\n% Constraints\nconstraint total_cost <= 5000; % Budget constraint\nconstraint total_generation >= yearly_demand; % Must satisfy yearly demand\n\nsolve satisfy;\n\noutput ['Number of solar panels: ' ++ show(num_panels) ++ 'XXxn' ++\n        'Total cost: $' ++ show(total_cost) ++ 'XXxn' ++\n        'Remaining budget: $' ++ show(remaining_budget) ++ 'XXxn' ++\n        'Electricity generated: ' ++ show(total_generation) ++ ' kWhXXxn' ++\n        'Additional electricity purchase: ' ++ show(additional_purchase) ++ ' kWhXXxn' ++\n        'Cost of purchase: $' ++ show(cost_of_purchase)];", "Concert Ticket Sales Problem": "% Given inputs from the problem description\nint: total_seats; % from dzn\nint: vip_seats; % from dzn\nint: special_guest_seats; % from dzn\nint: vip_price; % from dzn\nint: regular_price; % from dzn\nint: total_price_goal; % from dzn\nint: total_expenses; % from dzn\n\n% Decision variable: how many VIP and regular tickets to sell\nvar 0..vip_seats: vip_sold;\nvar 0..(total_seats - vip_seats): regular_sold;\n\n% Objective: maximize profit\nvar int: profit = (vip_sold * vip_price + regular_sold * regular_price) - total_expenses;\nconstraint profit >= total_price_goal - total_expenses; % We want to achieve the total price goal\nconstraint profit >= 0; % We want to make a profit\nconstraint vip_sold + regular_sold == total_seats - special_guest_seats; % All seats must be sold except for those reserved for special guests\nconstraint vip_sold <= vip_seats; % Can't sell more VIP tickets than available\nconstraint regular_sold <= total_seats - vip_seats; % Can't sell more regular tickets than available\n\nsolve satisfy;\n\noutput['VIP Tickets Sold: ' ++ show(vip_sold) ++ 'XXxn'];\noutput['Regular Tickets Sold: ' ++ show(regular_sold) ++ 'XXxn'];\noutput['Total Revenue: ' ++ show(vip_sold * vip_price + regular_sold * regular_price) ++ 'XXxn'];\noutput['Total Expenses: ' ++ show(total_expenses) ++ 'XXxn'];\noutput['Profit: ' ++ show(profit) ++ 'XXxn'];", "Board Type Quantities Problem": "% Number of board types\nint: n;\n\n% Arrays with the quantity of single and double slot boards for each type\narray[1..n] of int: single_slots; % from dzn\narray[1..n] of int: double_slots; % from dzn\n\n% Minimum quantity of LBOARD\nint: LBOARD;\n\n% Total number of single and double slots\nint: total_single_slots = sum(i in 1..n)(single_slots[i]);\nint: total_double_slots = sum(i in 1..n)(double_slots[i]);\n\n% Decision variables: number of single and double slots to use for each type\narray[1..n] of var 0..single_slots[1]: single_used; % single_slots[1] since it's the smallest array size\narray[1..n] of var 0..double_slots[1]: double_used; % double_slots[1] since it's the smallest array size\n\n% Constraint: If an LBOARD is present, it must be at least 2\nconstraint (single_used[1] + double_used[1] >= LBOARD * 2);\n\n% Constraint: The total number of slots used must be less than or equal to available slots\nconstraint sum(i in 1..n)(single_used[i] + 2 * double_used[i]) + 2 * sum(i in 2..n)(single_used[i] + 2 * double_used[i]) <= total_single_slots + 2 * total_double_slots;\n\n% Objective: Maximize the total number of slots used\nvar int: total_slots = sum(i in 1..n)(single_used[i] + 2 * double_used[i]);\n\nsolve maximize total_slots;\n\n% Output the results\noutput ['Single slots used: '] ++ [show(single_used[i]) | i in 1..n] ++ ['XXxn'] ++\n['Double slots used: '] ++ [show(double_used[i]) | i in 1..n] ++ ['XXxn'] ++\n['Total slots used: ', show(total_slots), 'XXxn'];", "3D Item Packing Problem": "int: n; % Number of itemsXXxnXXxn% 3D Space dimensionsXXxnint: spaceWidth;XXxnint: spaceHeight;XXxnint: spaceDepth;XXxnXXxn% Dimensions of each itemXXxnarray[1..n] of int: itemWidths;XXxnarray[1..n] of int: itemHeights;XXxnarray[1..n] of int: itemDepths;XXxnXXxn% Constraints on item placementXXxnarray[1..n, 1..n] of bool: noAdjacent; % noAdjacent[i,j] is true if items i and j cannot be adjacentXXxnXXxn% Decision variablesXXxnarray[1..n] of var 0..spaceWidth: itemXs; % X coordinates of the itemsXXxnarray[1..n] of var 0..spaceHeight: itemYs; % Y coordinates of the itemsXXxnarray[1..n] of var 0..spaceDepth: itemZs; % Z coordinates of the itemsXXxnXXxn% Objective: Minimize the total volume of the bounding boxXXxnvar int: boundingBoxVolume = max(itemXs) * max(itemYs) * max(itemZs);XXxnXXxn% ConstraintsXXxnconstraint forall(i, j in 1..n where i < j) (XXxn    if noAdjacent[i, j] thenXXxn        not (itemXs[i] + itemWidths[i] <= itemXs[j] XXx/ itemXs[j] + itemWidths[j] <= itemXs[i] XXx/XXxn             itemYs[i] + itemHeights[i] <= itemYs[j] XXx/ itemYs[j] + itemHeights[j] <= itemYs[i] XXx/XXxn             itemZs[i] + itemDepths[i] <= itemZs[j] XXx/ itemZs[j] + itemDepths[j] <= itemZs[i])XXxn    elseXXxn        trueXXxn    endifXXxn);XXxnXXxn% Symmetry breaking constraintsXXxnconstraint forall(i in 1..n) (XXxn    itemXs[i] + itemWidths[i] <= spaceWidth /XXxXXxn    itemYs[i] + itemHeights[i] <= spaceHeight /XXxXXxn    itemZs[i] + itemDepths[i] <= spaceDepthXXxn);XXxnXXxnsolve minimize boundingBoxVolume;XXxnXXxnoutput [XXxn    'Total volume of the bounding box: ', show(boundingBoxVolume), 'XXxn',XXxn    'Positions of the items:XXxn'XXxn] ++XXxn[XXxn    'Item ', show(i), ' (', show(itemWidths[i]), 'x', show(itemHeights[i]), 'x', show(itemDepths[i]), '): ',XXxn    'X: ', show(itemXs[i]), ', Y: ', show(itemYs[i]), ', Z: ', show(itemZs[i]), 'XXxn'XXxn| i in 1..nXXxn];", "Resource Allocation Problem": "% Parameters\nint: water; % from dzn\nint: land; % from dzn\nint: manure; % from dzn\nint: seeds; % from dzn\n\n% Crop types with requirements and yields\narray[1..4] of int: area = [2, 5, 3, 4]; % Area requirement per square meter for each crop\narray[1..4] of int: water_usage = [3, 2, 7, 4]; % Water usage per square meter for each crop\narray[1..4] of int: manure_usage = [2, 4, 5, 3]; % Manure usage per square meter for each crop\narray[1..4] of int: seeds_usage = [1, 2, 1, 3]; % Seeds usage per square meter for each crop\narray[1..4] of int: yield = [10, 5, 8, 7]; % Yield in kg per square meter for each crop\n\n% Constraints\nconstraint sum(i in 1..4)(area[i]) <= land /XXx % Total area used cannot exceed the available land\n          sum(i in 1..4)(water_usage[i] * area[i]) <= water /XXx % Total water used cannot exceed the available water\n          sum(i in 1..4)(manure_usage[i] * area[i]) <= manure + 20 * sum(i in 1..4)(area[i]) /XXx % Total manure used (including 20 kg per square meter)\n          sum(i in 1..4)(seeds_usage[i] * area[i]) <= seeds; % Total seeds used cannot exceed the available seeds\n\n% Objective: Check if the required weight can be achieved\nsolve satisfy;\n\n% Output: Whether the constraints are satisfied (Yes or No)\noutput['Can the required weight be achieved? ' ++ show(sum(i in 1..4)(yield[i] * area[i]))];", "Adjacent Furniture Pieces in a 3x3 Room": "% Parameters\nint: A; % from dzn\nint: B; % from dzn\nint: C; % from dzn\nint: D; % from dzn\nint: E; % from dzn\nint: F; % from dzn\nint: G; % from dzn\nint: H; % from dzn\nint: I; % from dzn\n\n% Constraints\nconstraint A != B /XXx A != C /XXx A != D /XXx A != E /XXx A != F /XXx A != G /XXx A != H /XXx A != I;\nconstraint B != C /XXx B != D /XXx B != E /XXx B != F /XXx B != G /XXx B != H /XXx B != I;\nconstraint C != D /XXx C != E /XXx C != F /XXx C != G /XXx C != H /XXx C != I;\nconstraint D != E /XXx D != F /XXx D != G /XXx D != H /XXx D != I;\nconstraint E != F /XXx E != G /XXx E != H /XXx E != I;\nconstraint F != G /XXx F != H /XXx F != I;\nconstraint G != H /XXx G != I;\nconstraint H != I;\n\n% Adjacency rules: Above, below, left, or right positions are considered adjacent; diagonal positions are not considered adjacent.\nconstraint (A = B XXx/ A = D) /XXx (B = A XXx/ B = C XXx/ B = E) /XXx (C = B XXx/ C = F) /XXx\n            (D = A XXx/ D = E XXx/ D = G) /XXx (E = B XXx/ E = D XXx/ E = F XXx/ E = H) /XXx\n            (F = C XXx/ F = E XXx/ F = I) /XXx (G = D XXx/ G = H) /XXx\n            (H = E XXx/ H = G XXx/ H = I) /XXx (I = F XXx/ I = H);\n\nsolve satisfy;\n\n% Output\noutput['The furniture pieces in the 3x3 room are: ' ++ show(A) ++ ', ' ++ show(B) ++ ', ' ++ show(C) ++ 'XXxn' ++\n       show(D) ++ ', ' ++ show(E) ++ ', ' ++ show(F) ++ 'XXxn' ++\n       show(G) ++ ', ' ++ show(H) ++ ', ' ++ show(I)];", "Board Allocation Model": "% ParametersXXxnint: n; % Number of board typesXXxnint: m; % Number of slotsXXxnXXxnarray[1..n] of int: board_quantities; % Quantity of each board typeXXxnXXxnint: board1_limit; % Maximum number of BOARD1 boardsXXxnint: board2_limit; % Maximum number of BOARD2 boardsXXxnint: board3_limit; % Maximum number of BOARD3 boardsXXxnint: lboard1_limit; % Maximum number of LBOARD1 boardsXXxnint: lboard2_limit; % Maximum number of LBOARD2 boardsXXxnXXxnarray[1..n] of int: board_slots; % Number of slots each board type takesXXxnXXxnvar 0..board1_limit: board1_count; % Number of BOARD1 boardsXXxnvar 0..board2_limit: board2_count; % Number of BOARD2 boardsXXxnvar 0..board3_limit: board3_count; % Number of BOARD3 boardsXXxnvar 0..lboard1_limit: lboard1_count; % Number of LBOARD1 boardsXXxnvar 0..lboard2_limit: lboard2_count; % Number of LBOARD2 boardsXXxnXXxn% Objective: Maximize the total boardsXXxnvar int: total_boards = board1_count + board2_count + board3_count + lboard1_count + lboard2_count;XXxnXXxn% Constraint: Consider only valid quantities of each boardXXxnconstraint board1_count * board_slots[1] + board2_count * board_slots[2] + board3_count * board_slots[3] + lboard1_count * board_slots[4] + lboard2_count * board_slots[5] <= m;XXxnXXxn% Constraint: Ensure we don't use more boards than availableXXxnconstraint board1_count <= board1_limit /XXxXXxn           board2_count <= board2_limit /XXxXXxn           board3_count <= board3_limit /XXxXXxn           lboard1_count <= lboard1_limit /XXxXXxn           lboard2_count <= lboard2_limit;XXxnXXxn% Objective: Maximize the number of boards usedXXxnsolve maximize total_boards;XXxnXXxn% Output the board allocationXXxnoutput ['Optimal Allocation:XXxn'] ++XXxn       ['BOARD1: ' ++ show(board1_count) ++ 'XXxn'] ++XXxn       ['BOARD2: ' ++ show(board2_count) ++ 'XXxn'] ++XXxn       ['BOARD3: ' ++ show(board3_count) ++ 'XXxn'] ++XXxn       ['LBOARD1: ' ++ show(lboard1_count) ++ 'XXxn'] ++XXxn       ['LBOARD2: ' ++ show(lboard2_count) ++ 'XXxn'] ++XXxn       ['Total boards: ' ++ show(total_boards) ++ 'XXxn'];", "3D Non-Intersecting Packing Problem": "```minizinc\n% Input parameters\nint: num_items;\nint: num_spaces;\narray[1..num_items, 1..3] of int: item_dimensions; % (width, height, depth)\narray[1..num_spaces, 1..3] of int: space_dimensions; % (width, height, depth)\n\n% Decision variables\narray[1..num_items, 1..3] of var 1..num_spaces: item_placement; % Item i placed in space j\n\n% Constraints\nconstraint forall(i in 1..num_items)(\n    item_dimensions[i, 1] <= space_dimensions[item_placement[i, 1], 1] /XXx\n    item_dimensions[i, 2] <= space_dimensions[item_placement[i, 1], 2] /XXx\n    item_dimensions[i, 3] <= space_dimensions[item_placement[i, 1], 3]\n);\n\nconstraint forall(i, j in 1..num_items where i < j)(\n    item_placement[i, 1] != item_placement[j, 1] XXx/\n    item_placement[i, 2] != item_placement[j, 2] XXx/\n    item_placement[i, 3] != item_placement[j, 3]\n);\n\n% Objective function\nsolve satisfy;\n\n% Output\noutput ['Item Placement:'] item_placement;\n```", "Geometric Plane Constraint Problem": "```minizinc\nint: x; % from dzn\nint: y; % from dzn\n\narray[1..3] of var int: itemWidth;\narray[1..3] of var int: itemHeight;\narray[1..3] of var int: itemDepth;\n\nconstraint forall(i in 1..3)(\n    itemWidth[i] > 0 /XXx itemHeight[i] > 0 /XXx itemDepth[i] > 0\n);\n\nconstraint forall(i in 1..3)(\n    itemWidth[i] <= 10 /XXx itemHeight[i] <= 10 /XXx itemDepth[i] <= 10\n);\n\nconstraint forall(i in 1..3)(\n    itemWidth[i] + x <= 10 /XXx itemHeight[i] + y <= 10\n);\n\noutput [itemWidth, itemHeight, itemDepth];\n```", "Energy_Budget_Optimization": "```minizinc\nint: yearly_electricity_demand;\nint: cost_per_solar_panel;\nint: electricity_generated_per_solar_panel;\nint: required_number_of_solar_panels;\nfloat: cost_per_unit_of_purchased_electricity;\nint: yearly_budget_for_energy;\n\nvar int: total_cost_solar_panels;\nvar int: cost_additional_electricity;\n\nconstraint total_cost_solar_panels <= yearly_budget_for_energy;\nconstraint cost_additional_electricity <= yearly_budget_for_energy - total_cost_solar_panels;\nconstraint (electricity_generated_per_solar_panel * required_number_of_solar_panels) + (yearly_electricity_demand - (electricity_generated_per_solar_panel * required_number_of_solar_panels)) * cost_per_unit_of_purchased_electricity >= yearly_electricity_demand;\n\noutput['Total Cost of Solar Panels: XXx(total_cost_solar_panels)'];\noutput['Cost of Additional Electricity: XXx(cost_additional_electricity)'];\n```", "Precision_Agriculture_Field_Management": "int: total_area; % Total area of land\nint: total_water; % Total water available\nint: total_manure; % Total manure available\nint: total_seeds; % Total seeds available\n\nint: crop1_yield; % Yield of Crop 1 in kg/sqm\nint: crop1_water_per_unit; % Water required per sqm for Crop 1\nfloat: crop1_seeds_per_unit; % Seeds required per sqm for Crop 1\n\nint: crop2_yield; % Yield of Crop 2 in kg/sqm\nint: crop2_water_per_unit; % Water required per sqm for Crop 2\nfloat: crop2_seeds_per_unit; % Seeds required per sqm for Crop 2\n\nint: crop3_yield; % Yield of Crop 3 in kg/sqm\nint: crop3_water_per_unit; % Water required per sqm for Crop 3\nfloat: crop3_seeds_per_unit; % Seeds required per sqm for Crop 3\n\n% Required crop weights\nint: required_crop1_weight; % Crop 1 required weight\nint: required_crop2_weight; % Crop 2 required weight\nint: required_crop3_weight; % Crop 3 required weight\n\n% Constraints\nconstraint total_area * crop1_water_per_unit <= total_water;\nconstraint total_area * crop2_water_per_unit <= total_water;\nconstraint total_area * crop3_water_per_unit <= total_water;\n\nconstraint total_area * 20 <= total_manure; % 20kg manure per sqm\n\nconstraint total_area * crop1_seeds_per_unit <= total_seeds;\nconstraint total_area * crop2_seeds_per_unit <= total_seeds;\nconstraint total_area * crop3_seeds_per_unit <= total_seeds;\n\nconstraint crop1_yield * total_area >= required_crop1_weight;\nconstraint crop2_yield * total_area >= required_crop2_weight;\nconstraint crop3_yield * total_area >= required_crop3_weight;\n\n% Objective: Check if the requirements can be met by the available resources\nsolve satisfy;\n\noutput ['The requirements can be met with the available resources.'];", "3D_Bin_Packing_Problem": "% Define the number of bins and itemsXXxnint: n_bins; % Number of binsXXxnint: n_items; % Number of itemsXXxnXXxn% Define the dimensions of the binsXXxnarray[1..n_bins] of int: bin_width; % Width of each binXXxnarray[1..n_bins] of int: bin_height; % Height of each binXXxnarray[1..n_bins] of int: bin_depth; % Depth of each binXXxnXXxn% Define the dimensions of the itemsXXxnarray[1..n_items] of int: item_width; % Width of each itemXXxnarray[1..n_items] of int: item_height; % Height of each itemXXxnarray[1..n_items] of int: item_depth; % Depth of each itemXXxnXXxn% Define the decision variable: item_assignment[i, j] is 1 if item i is in bin jXXxnarray[1..n_items, 1..n_bins] of var 0..1: item_assignment;XXxnXXxn% Placement constraints: each item must fit in a single binXXxnconstraintXXxn    forall(i in 1..n_items) (XXxn        sum(j in 1..n_bins) (item_assignment[i, j]) = 1XXxn    );XXxnXXxn% Size constraints: each bin must not overflowXXxnconstraintXXxn    forall(j in 1..n_bins) (XXxn        sum(i in 1..n_items) (item_width[i] * item_assignment[i, j]) <= bin_width[j] /XXxXXxn        sum(i in 1..n_items) (item_height[i] * item_assignment[i, j]) <= bin_height[j] /XXxXXxn        sum(i in 1..n_items) (item_depth[i] * item_assignment[i, j]) <= bin_depth[j]XXxn    );XXxnXXxn% Objective: Minimize the number of bins usedXXxnvar int: bins_used = sum(j in 1..n_bins) (max(i in 1..n_items) (item_assignment[i, j]));XXxnsolve minimize bins_used;XXxnXXxnoutput ['Bins used: ', show(bins_used), 'XXxn'];XXxnoutput ['Item assignments:XXxn'];XXxnoutput [XXxn    if item_assignment[i, j] = 1 then 'Item ', show(i), ' in Bin ', show(j), 'XXxn' else '' endifXXxn    | i in 1..n_items, j in 1..n_binsXXxn];", "3D_Non_Intersecting_Packing": "% The MiniZinc code can be generated given the model description and semantic entities. If you provide the model description and the semantic entities, I can create the MiniZinc code for you.", "3D Non-Intersecting Packing": "int: width; % from dzn\nint: height; % from dzn\nint: depth; % from dzn\n\narray[1..3, 1..3] of int: item_dims; % Dimensions of the 3 items\n\narray[1..3] of var 0..1: item_in_space1; % 1 if item in space 1, 0 if in space 2\narray[1..3, 1..3] of var 0..10: item_pos; % Position of each item\n\n% Ensure items fit within the space and do not intersect with each other\nconstraint\n  forall(i, j in 1..3 where i < j)(\n    if item_in_space1[i] = item_in_space1[j] then\n      (item_pos[i, 1] + item_dims[i, 1] <= item_pos[j, 1] XXx/\n       item_pos[j, 1] + item_dims[j, 1] <= item_pos[i, 1]) /XXx\n      (item_pos[i, 2] + item_dims[i, 2] <= item_pos[j, 2] XXx/\n       item_pos[j, 2] + item_dims[j, 2] <= item_pos[i, 2]) /XXx\n      (item_pos[i, 3] + item_dims[i, 3] <= item_pos[j, 3] XXx/\n       item_pos[j, 3] + item_dims[j, 3] <= item_pos[i, 3])\n    else\n      true\n    endif\n  );\n\n% Ensure items do not intersect with the specified planes\nconstraint\n  forall(i in 1..3)(\n    (item_pos[i, 1] + item_dims[i, 1] <= 2 XXx/ item_pos[i, 1] >= 2) /XXx\n    (item_pos[i, 2] + item_dims[i, 2] <= 4 XXx/ item_pos[i, 2] >= 4) /XXx\n    (item_pos[i, 3] + item_dims[i, 3] <= 2 XXx/ item_pos[i, 3] >= 2)\n  );\n\n% Ensure items are within the space dimensions\nconstraint\n  forall(i in 1..3)(\n    item_pos[i, 1] + item_dims[i, 1] <= width /XXx\n    item_pos[i, 2] + item_dims[i, 2] <= height /XXx\n    item_pos[i, 3] + item_dims[i, 3] <= depth\n  );\n\n% Objective: Find a valid placement\nsolve satisfy;\n\noutput[\n  'Item ', show(item_dims[1, 1]), 'x', show(item_dims[1, 2]), 'x', show(item_dims[1, 3]),\n  ' in space ', show(item_in_space1[1]), ' at position (', show(item_pos[1, 1]), ', ',\n  show(item_pos[1, 2]), ', ', show(item_pos[1, 3]), ')', 'XXxn',\n  'Item ', show(item_dims[2, 1]), 'x', show(item_dims[2, 2]), 'x', show(item_dims[2, 3]),\n  ' in space ', show(item_in_space1[2]), ' at position (', show(item_pos[2, 1]), ', ',\n  show(item_pos[2, 2]), ', ', show(item_pos[2, 3]), ')', 'XXxn',\n  'Item ', show(item_dims[3, 1]), 'x', show(item_dims[3, 2]), 'x', show(item_dims[3, 3]),\n  ' in space ', show(item_in_space1[3]), ' at position (', show(item_pos[3, 1]), ', ',\n  show(item_pos[3, 2]), ', ', show(item_pos[3, 3]), ')'\n];", "Concert Ticket Selling Model": "int: total_seats;  % Total seats available\nint: vip_seats;    % VIP seats\nint: regular_seats;    % Regular (non-VIP) seats\nint: special_guest_seats; % Free seats for special guests\nint: vip_ticket_price;    % Price of a VIP ticket\nint: regular_ticket_price;    % Price of a regular ticket\nint: total_price_goal;    % Total amount to be raised\nint: total_expenses;    % Total expenses including staff, fund, etc.\n\n% Constraints\nconstraint 0 <= vip_seats /XXx vip_seats <= 200;\nconstraint 0 <= special_guest_seats /XXx special_guest_seats <= 400;\nconstraint 0 <= vip_ticket_price;\nconstraint 0 <= regular_ticket_price;\nconstraint 0 <= total_price_goal;\nconstraint 0 <= total_expenses;\n\n% Revenue calculation\nvar int: vip_tickets_sold;    % Number of VIP tickets sold\nvar int: regular_tickets_sold;    % Number of regular tickets sold\n\nvar int: revenue = vip_tickets_sold * vip_ticket_price + regular_tickets_sold * regular_ticket_price;\nvar int: expenses = total_expenses;\nvar int: profit = revenue - expenses;\n\n% Constraints\nconstraint 0 <= vip_tickets_sold /XXx vip_tickets_sold <= vip_seats;\nconstraint 0 <= regular_tickets_sold /XXx regular_tickets_sold <= regular_seats;\nconstraint vip_tickets_sold + regular_tickets_sold <= total_seats;\nconstraint special_guest_seats == 400;  % Since it's a fixed requirement\n\n% Objective: Meet the price goal and maximize profit\nsolve satisfy;\n\n% Output the results\noutput['VIP Tickets Sold: XXx(vip_tickets_sold)XXxn'];\noutput['Regular Tickets Sold: XXx(regular_tickets_sold)XXxn'];\noutput['Total Revenue: XXx(revenue)XXxn'];\noutput['Total Expenses: XXx(expenses)XXxn'];\noutput['Profit: XXx(profit)XXxn'];", "Concert Ticket Sales Model": "int: total_seats;  % 1000 total seatsXXxnint: vip_seats;    % 200 VIP seatsXXxnint: free_seats;   % 400 free seats for special guestsXXxnint: vip_price;    % $170 per VIP ticketXXxnint: regular_price; % $60 per regular ticketXXxnint: total_price_goal; % $50,000 total revenue goalXXxnint: total_expenses;  % $45,000 total expensesXXxnXXxnXXxn% Decision variables: Number of VIP and regular tickets soldXXxnvar 0..vip_seats: vip_sold;  % At most 200 VIP tickets can be soldXXxnvar 0..free_seats: free_sold;  % All free seats must be used by special guestsXXxnvar 0..(total_seats - vip_seats - free_seats): regular_sold;  % Regular tickets sold is limited by the available seatsXXxnXXxnXXxn% Objective: Maximize profit (revenue - expenses)XXxnvar int: revenue = vip_sold * vip_price + regular_sold * regular_price;XXxnvar int: profit = revenue - total_expenses;XXxnXXxn% ConstraintsXXxnconstraint revenue >= total_price_goal;  % Revenue must meet the goalXXxnconstraint profit >= total_price_goal - total_expenses;  % Ensure the profit meets the desired amountXXxnXXxnsolve maximize profit;XXxnXXxnoutput [XXxn  'VIP tickets sold: ', show(vip_sold), 'XXxn',XXxn  'Regular tickets sold: ', show(regular_sold), 'XXxn',XXxn  'Total revenue: $', show(revenue), 'XXxn',XXxn  'Total profit: $', show(profit), 'XXxn'XXxn];", "Concert Ticket Selling": "int: total_seats;  % Total number of seatsXXxnint: vip_seat_price; % Price for a VIP seatXXxnint: regular_seat_price;  % Price for a regular seatXXxnint: total_price_goal;  % Goal total revenueXXxnint: total_expenses;  % Total expensesXXxnint: vip_seats;  % Available VIP seatsXXxnint: free_special_guest_seats;  % Available free seats for special guestsXXxnXXxn% Decision variables: number of VIP and regular seats soldXXxnvar 0..200: vip_sold;  % Maximum of 200 VIP seatsXXxnvar 0..400: free_special_guest_sold;  % Maximum of 400 free seats for special guestsXXxnXXxn% Revenue calculationXXxnvar int: total_revenue = vip_sold * vip_seat_price + (total_seats - vip_sold - free_special_guest_sold) * regular_seat_price;XXxnXXxn% Objective: Maximize profitXXxnvar int: profit = total_revenue - total_expenses;XXxnXXxn% ConstraintsXXxnconstraint vip_sold <= vip_seats /XXxXXxn          vip_sold + free_special_guest_sold <= total_seats /XXxXXxn          total_revenue >= total_price_goal;XXxnXXxnsolve maximize profit;", "3D Non-Intersecting Item Packing": "% 3D Non-Intersecting Item Packing MiniZinc Model\n% Based on the provided description\n\nint: n = 5; % Number of items\nint: m = 3; % Number of spaces\n\n% Item dimensions: Width, Height, Depth\narray[1..n, 1..3] of int: items; % from dzn\n\n% Adjacency matrix for items\narray[1..n, 1..n] of int: adjacent = array2d(1..n, 1..n,\n    [0, 1, 1, 0, 1,\n     1, 0, 1, 0, 0,\n     1, 1, 0, 1, 0,\n     0, 0, 1, 0, 1,\n     1, 0, 0, 1, 0]);\n\n% Decision variable: item i in space j\narray[1..n, 1..m] of var 0..1: x;\n\n% Constraints: Each item in one space and non-adjacent items in the same space\nconstraint\n    forall(i in 1..n)(\n        sum(j in 1..m)(x[i, j]) = 1\n    ) /XXx\n    forall(i in 1..n, j in 1..m, k in 1..n where i != k /XXx adjacent[i, k] = 1)(\n        x[i, j] + x[k, j] <= 1\n    );\n\n% Objective: We want to pack all items into the minimum number of spaces\nvar int: packedSpaces = sum(j in 1..m)(\n    bool2int(sum(i in 1..n)(x[i, j]) > 0)\n);\n\nsolve minimize packedSpaces;\n\n% Output the assignment of items to spaces\noutput['Items in each space:'] ++ [show(i) ++ ' -> Space ' ++ show(j) ++ 'XXxn' |\n    i in 1..n, j in 1..m, x[i, j] = 1];\n\n% Ensure that the solver finds all solutions with minimum packedSpaces\nconstraint packedSpaces = m;\n\n% Find all solutions with the minimum number of used spaces\nsolve satisfy;\n\n% Output the assignment of items to spaces\noutput['Items in each space:'] ++ [show(i) ++ ' -> Space ' ++ show(j) ++ 'XXxn' |\n    i in 1..n, j in 1..m, x[i, j] = 1];", "Classroom_Scheduling": "int: n; % Number of classroomsXXxnint: m; % Maximum hours per classroom per dayXXxnint: total_weekly_hours; % Total weekly hoursXXxnint: k; % Number of classesXXxnint: min_subjects_per_class; % Minimum subjects per classXXxnint: max_subjects_per_class; % Maximum subjects per classXXxnint: days_per_week = 5; % Days of the weekXXxnint: hours_per_day = 3; % Hours of operation per dayXXxnint: subjects = 4; % Number of subjects (A, B, C, D)XXxnXXxn% Class/Subject Qty matrix: sessions needed per subject for each classXXxnarray[1..k, 1..subjects] of int: class_subject_qty;XXxnXXxn% Decision variable: x[c, d, h, s] = 1 if class c has session of subject s on day d, hour hXXxnarray[1..k, 1..days_per_week, 1..hours_per_day, 1..subjects] of var 0..1: x;XXxnXXxn% Each class must have a session for each subject on one dayXXxnconstraintXXxn    forall(c in 1..k, s in 1..subjects) (XXxn        sum([x[c, d, h, s] | d in 1..days_per_week, h in 1..hours_per_day]) = class_subject_qty[c, s]XXxn    );XXxnXXxn% Classroom hour limit per dayXXxnconstraintXXxn    forall(d in 1..days_per_week, h in 1..hours_per_day) (XXxn        sum([x[c, d, h, s] * class_subject_qty[c, s] | c in 1..k, s in 1..subjects]) <= n * mXXxn    );XXxnXXxn% Total weekly hours constraintXXxnconstraintXXxn    sum([x[c, d, h, s] * class_subject_qty[c, s] | c in 1..k, s in 1..subjects, h in 1..hours_per_day, d in 1..days_per_week]) <= total_weekly_hours;XXxnXXxn% Min and max subject constraints for each classXXxnconstraintXXxn    forall(c in 1..k) (XXxn        min_subjects_per_class <= sum([x[c, d, h, s] | s in 1..subjects, h in 1..hours_per_day, d in 1..days_per_week]) /XXx\n        sum([x[c, d, h, s] | s in 1..subjects, h in 1..hours_per_day, d in 1..days_per_week]) <= max_subjects_per_classXXxn    );XXxnXXxnsolve satisfy;XXxnXXxn% OutputXXxnoutput [XXxn    'Class/Subject Schedule (1: Class, 2: Day, 3: Hour, 4: Subject):XXxn',XXxn    join([show(c) ++ '  ' ++ show(d) ++ '  ' ++ show(h) ++ '  ' ++ show(s) ++ 'XXxn' |XXxn        c in 1..k, d in 1..days_per_week, h in 1..hours_per_day, s in 1..subjects], '')XXxn];", "Concert_Profit_Optimization": "int: regularTicketPrice;\nint: vipTicketPrice;\nint: regularSeatsAvailable;\nint: vipSeatsAvailable;\nint: freeSeatsAvailable;\nint: staffSalary;\nint: concertFund;\nint: revenueGoal;\n\nvar 0..regularSeatsAvailable: regularTickets;\nvar 0..vipSeatsAvailable: vipTickets;\nvar 0..freeSeatsAvailable: freeTickets;\n\nvar int: regularRevenue = regularTickets * regularTicketPrice;\nvar int: vipRevenue = vipTickets * vipTicketPrice;\nvar int: totalRevenue = regularRevenue + vipRevenue;\nvar int: totalTickets = regularTickets + vipTickets + freeTickets;\n\nconstraint regularTickets + vipTickets + freeTickets <= regularSeatsAvailable + vipSeatsAvailable + freeSeatsAvailable /XXx\n          vipTickets <= vipSeatsAvailable /XXx\n          freeTickets <= freeSeatsAvailable /XXx\n          totalRevenue >= revenueGoal /XXx\n          totalTickets == 500 /XXx\n          totalRevenue >= 3 * staffSalary + concertFund;\n\nsolve maximize totalRevenue - 3 * staffSalary - concertFund;\n\noutput ['Regular tickets: XXx(regularTickets)XXxn',\n    'VIP tickets: XXx(vipTickets)XXxn',\n    'Free tickets: XXx(freeTickets)XXxn',\n    'Profit: XXx(totalRevenue - 3 * staffSalary - concertFund)XXxn'];", "Concert_Revenue_Optimization": "int: regular_price;  % Price of a regular ticketXXxnint: vip_price;      % Price of a VIP ticketXXxnint: regular_seats;   % Number of regular seatsXXxnint: vip_seats;       % Number of VIP seatsXXxnint: free_seats;      % Number of free seatsXXxnint: revenue_goal;   % Total revenue goalXXxnint: expenses_goal = 45000;  % Expenses goalXXxnXXxn% VariablesXXxnvar 0..regular_seats: regular_sold;  % Number of regular tickets soldXXxnvar 0..vip_seats: vip_sold;          % Number of VIP tickets soldXXxnXXxn% ConstraintsXXxnconstraint regular_sold + vip_sold <= regular_seats + vip_seats + free_seats;  % Seats used must not exceed the total availableXXxnconstraint vip_sold <= 200;  % Maximum 200 VIP seats soldXXxnconstraint free_seats + vip_sold <= 400;  % Ensure free + VIP seats used does not exceed 400XXxnXXxn% RevenueXXxnvar int: revenue = regular_sold * regular_price + vip_sold * vip_price;  % Total revenueXXxnconstraint revenue >= revenue_goal;  % Must reach the revenue goal to cover expenses and profitXXxnXXxn% Goal: Maximize profitXXxnvar int: profit = revenue - expenses_goal;  % Total profitXXxnsolve maximize profit;XXxnXXxn% OutputXXxnoutput ['Regular tickets sold: ' ++ show(regular_sold) ++ 'XXxn' ++XXxn        'VIP tickets sold: ' ++ show(vip_sold) ++ 'XXxn' ++XXxn        'Revenue: $' ++ show(revenue) ++ 'XXxn' ++XXxn        'Profit: $' ++ show(profit)];", "Home_Electricity_Management": "int: budget = 5000; % from dzn\nint: cost_per_panel = 830; % from dzn\nint: electricity_per_panel = 800; % from dzn\nint: required_panels = 6;\nfloat: cost_per_kwh = 0.5; % from dzn\nint: demand = 4000; % from dzn\n\n% Decision Variables\nvar 0..required_panels: panels_purchased; % The number of solar panels purchased\n\n% Constraints\nconstraint panels_purchased * cost_per_panel <= budget; % Cost constraint\nconstraint budget - panels_purchased * cost_per_panel >= 0; % Remaining budget for purchased electricity\nconstraint panels_purchased * electricity_per_panel + (demand - panels_purchased * electricity_per_panel) >= demand; % Ensuring demand is met\n\n% Objective\nsolve satisfy;\n\n% Output\noutput ['Solar Panels Purchased: ' ++ show(panels_purchased) ++ 'XXxnRemaining budget: $' ++ show(budget - panels_purchased * cost_per_panel) ++ 'XXxnElectricity generated: ' ++ show(panels_purchased * electricity_per_panel) ++ ' kWh'];", "Solar_Panel_Electricity_Constraints": "int: solar_panel_cost;  % Cost of solar panelsXXxnfloat: electricity_cost;    % Cost of purchased electricityXXxnint: budget;              % Total budgetXXxnXXxnint: solar_panel_electricity;  % Electricity generated by solar panelsXXxnvar 0..10000: purchased_electricity;  % Electricity purchasedXXxnXXxnint: total_demand;          % Total electricity demandXXxnXXxnconstraint solar_panel_cost * 6 + (electricity_cost * 8760) * purchased_electricity <= budget;XXxnconstraint solar_panel_electricity * 6 + purchased_electricity * 8760 >= total_demand * 8760;XXxnXXxnsolve satisfy;  % Objective: satisfy all constraintsXXxnXXxnoutput [XXxn  'Solar Panel Cost: ', show(solar_panel_cost * 6), 'XXxn',XXxn  'Electricity Cost: ', show(electricity_cost * purchased_electricity * 8760), 'XXxn',XXxn  'Total Budget: ', show(budget), 'XXxn',XXxn  'Electricity from Solar Panels: ', show(solar_panel_electricity * 6), 'XXxn',XXxn  'Electricity Purchased: ', show(purchased_electricity), 'XXxn',XXxn  'Total Demand: ', show(total_demand), 'XXxn'XXxn];", "Concert_Ticket_Sales_Optimization": "int: available_seats;  % total seats availableXXxnint: vip_price;  % price of a VIP ticketXXxnint: regular_price;  % price of a regular ticketXXxnint: expenses = 45000;  % fixed expensesXXxnXXxn% Input parametersXXxnvar 0..available_seats: vip_tickets;  % number of VIP tickets soldXXxnvar 0..available_seats: regular_tickets;  % number of regular tickets soldXXxnXXxn% ConstraintsXXxnconstraint vip_tickets + regular_tickets <= available_seats;  % total seats usedXXxnconstraint vip_tickets <= 200;  % VIP seats constraintXXxnconstraint regular_tickets <= 400;  % Free seats constraintXXxnXXxn% Calculate total revenue and profitXXxnvar int: total_revenue = vip_tickets * vip_price + regular_tickets * regular_price;  % total revenueXXxnvar int: goal_profit = total_revenue - expenses;  % goal profitXXxnXXxn% Objective: Maximize profitXXxnsolve maximize goal_profit;XXxnXXxn% OutputXXxnoutput['VIP tickets: ', show(vip_tickets), 'XXxnRegular tickets: ', show(regular_tickets), 'XXxnTotal revenue: $', show(total_revenue), 'XXxnProfit: $', show(goal_profit)];", "ConcertTicketSelling": "int: totalSeats; % totalSeats = 1000;XXxnint: vipSeats; % vipSeats = 200;XXxnint: regularSeats = totalSeats - vipSeats;XXxnint: vipPrice; % vipPrice = 170;XXxnint: regularPrice; % regularPrice = 60;XXxnint: totalGoal; % totalGoal = 50000;XXxnXXxn% Decision VariablesXXxnvar 0..vipSeats: vipSold;XXxnvar 0..regularSeats: regularSold;XXxnXXxnconstraint vipSold * vipPrice + regularSold * regularPrice == totalGoal;XXxnconstraint vipSold <= vipSeats;XXxnconstraint regularSold <= regularSeats;XXxnXXxn% Objective: Maximize profitXXxnvar int: profit = (vipSold * vipPrice + regularSold * regularPrice) - 45000; % 45000 is total expensesXXxnsolve maximize profit;XXxnXXxnoutput [profit, vipSold, regularSold];", "ConcertProfitMaximization": "int: regular_ticket_price;  % Price of a regular ticket (input)XXxnint: vip_ticket_price;      % Price of a VIP ticket (input)XXxnXXxnint: available_regular_seats;  % Available regular seats (input)XXxnint: available_vip_seats;      % Available VIP seats (input)XXxnint: available_free_seats;     % Available free seats (input)XXxnXXxnint: cost_of_free_tickets;  % Cost of a free ticket (input)XXxnint: total_expense_goal;    % Goal for covering costs (input)XXxnint: revenue_goal;          % Goal for total revenue (input)XXxnint: total_price_goal;      % Goal for total ticket sales (input)XXxnXXxnint: revenue_coefficient;     % Coefficient for revenue (input)XXxnint: vip_attendees_coefficient;  % Coefficient for VIP attendees (input)XXxnint: free_attendees_coefficient; % Coefficient for free attendees (input)XXxnXXxn% Decision variablesXXxnvar 0..available_regular_seats: regular_tickets_sold;  % Variables representing tickets soldXXxnvar 0..available_vip_seats: vip_tickets_sold;XXxnvar 0..available_free_seats: free_tickets_sold;XXxnXXxn% ConstraintsXXxnconstraintXXxn   regular_tickets_sold + vip_tickets_sold + free_tickets_sold <= available_regular_seats + available_vip_seats + available_free_seats /XXx\n   vip_tickets_sold <= available_vip_seats /XXx\n   free_tickets_sold <= available_free_seats /XXx\n   revenue_coefficient * (regular_ticket_price * regular_tickets_sold + vip_ticket_price * vip_tickets_sold + free_tickets_sold * cost_of_free_tickets) >= revenue_goal /XXx\n   cost_of_free_tickets * free_tickets_sold + vip_ticket_price * vip_tickets_sold + regular_ticket_price * regular_tickets_sold >= total_expense_goal /XXx\n   regular_ticket_price * regular_tickets_sold + vip_ticket_price * vip_tickets_sold + free_tickets_sold * cost_of_free_tickets >= total_price_goal;XXxnXXxn% Objective: Maximize the profitXXxnvar int: profit = regular_ticket_price * regular_tickets_sold + vip_ticket_price * vip_tickets_sold - cost_of_free_tickets * free_tickets_sold;XXxnsolve maximize profit;XXxnXXxn% OutputXXxnoutput [XXxn  'Regular Tickets Sold: ', show(regular_tickets_sold), 'XXxn',XXxn  'VIP Tickets Sold: ', show(vip_tickets_sold), 'XXxn',XXxn  'Free Tickets Sold: ', show(free_tickets_sold), 'XXxn',XXxn  'Total Revenue: ', show(regular_ticket_price * regular_tickets_sold + vip_ticket_price * vip_tickets_sold + free_tickets_sold * cost_of_free_tickets), 'XXxn',XXxn  'Total Cost: ', show(free_tickets_sold * cost_of_free_tickets + vip_ticket_price * vip_tickets_sold + regular_ticket_price * regular_tickets_sold), 'XXxn',XXxn  'Profit: ', show(profit), 'XXxn'XXxn];", "ClassroomScheduling": "int: n; % Total available classroomsXXxnint: m; % Maximum hours per classroom per dayXXxnint: hours_per_day = 3; % Total hours the school operates per dayXXxnint: days_per_week = 5; % Total days in a weekXXxnint: z; % Maximum subjects per class per weekXXxnint: k; % Total classesXXxnXXxn% SubjectsXXxnset of int: Subjects = 1..4; % A=1, B=2, C=3, D=4XXxnXXxn% Class/Subject Qty matrix: Each row corresponds to a classXXxnarray[1..k, Subjects] of int: ClassSubjectQty;XXxnXXxn% Decision variablesXXxnarray[1..k, 1..days_per_week, Subjects] of var 0..z: Schedule;XXxnXXxn% Each class for each subject per day needs to be less than or equal to the available hoursXXxnconstraintXXxn    forall(c in 1..k, d in 1..days_per_week, s in Subjects) (XXxn        Schedule[c, d, s] * ClassSubjectQty[c, s] <= mXXxn    );XXxnXXxn% Each class must have a balanced schedule across all days (if possible)XXxnconstraintXXxn    forall(c in 1..k) (XXxn        sum(d in 1..days_per_week, s in Subjects)(Schedule[c, d, s] * ClassSubjectQty[c, s]) >= hours_per_day * days_per_weekXXxn    );XXxnXXxn% Classes cannot exceed the available classroom hours per dayXXxnconstraintXXxn    forall(d in 1..days_per_week) (XXxn        sum(c in 1..k, s in Subjects)(Schedule[c, d, s] * ClassSubjectQty[c, s]) <= n * mXXxn    );XXxnXXxn% Objective: Maximize the overall class sessionsXXxnsolve satisfy;XXxnXXxn% Output the scheduleXXxnoutput [XXxn    'Schedule:XXxn'XXxn] ++XXxn[XXxn    if d = 1 then 'XXxnDay ' ++ show(d) ++ ':XXxn' else '' endif ++XXxn    'Class ' ++ show(c) ++ ':XXxt' ++XXxn    concat([' ' ++ show(Schedule[c, d, s]) | s in Subjects]) ++ 'XXxn'XXxn    | c in 1..k, d in 1..days_per_weekXXxn];", "false": "% The 3D Bin Packing Problem\n% Place 5 items in 3 spaces without intersection\n% Each item has a width, height, and depth\n% The objective is to minimize the number of empty spaces\n\nint: n = 5;  % Number of items\nint: m = 3;  % Number of spaces\n\n% Item dimensions (width, height, depth) from dzn\narray[1..n, 1..3] of int: items;  % from dzn\n\n% Space dimensions\nint: space_width = 10;\nint: space_height = 10;\nint: space_depth = 10;\n\n% Decision variables\n% x[i, j] = 1 if item i is placed in space j, 0 otherwise\narray[1..n, 1..m] of var 0..1: x;\n\n% Ensure that each item is placed exactly once\nconstraint forall(i in 1..n)(\n    sum(j in 1..m)(x[i, j]) = 1\n);\n\n% Ensure that the sum of dimensions in each space does not exceed the box dimensions\nconstraint forall(j in 1..m)(\n    sum(i in 1..n)(items[i, 1] * x[i, j]) <= space_width /XXx\n    sum(i in 1..n)(items[i, 2] * x[i, j]) <= space_height /XXx\n    sum(i in 1..n)(items[i, 3] * x[i, j]) <= space_depth\n);\n\n% Objective: Minimize the number of empty spaces\nvar int: empty_spaces = sum(j in 1..m)(\n    1 - sum(i in 1..n)(x[i, j])\n);\n\nsolve minimize empty_spaces;\n\noutput['Empty Spaces: ', show(empty_spaces), 'XXxn'];\n\n% Output the placement of items in each space\noutput['Items Placement:XXxn'];\nfor j in 1..m do\n    output['Space ', show(j), ':XXxn'];\n    for i in 1..n do\n        output['Item ', show(i), ': ', show(x[i, j]), 'XXxn'];\n    end;\nend;", "Board_Allocation_Model": "int: n_BOARD; % Number of single-slot boards\nint: n_LBOARD; % Number of double-slot boards\nint: m;        % Total slots available\n\n% Quantity of each board type\narray[1..n_BOARD] of int: quantity_SINGLE;\narray[1..n_LBOARD] of int: quantity_DOUBLE;\n\n% Each board requires either 1 or 2 slots\nint: BOARD_slots = 1;\nint: LBOARD_slots = 2;\n\n% Decision variables: number of each board type\nvar 0..m: BOARD1; % Single-slot boards\nvar 0..m: BOARD2; % Single-slot boards\nvar 0..m: BOARD3; % Single-slot boards\nvar 0..m: LBOARD1; % Double-slot boards\nvar 0..m: LBOARD2; % Double-slot boards\n\n% Constraints based on available slots\nconstraint BOARD1 * BOARD_slots + BOARD2 * BOARD_slots + BOARD3 * BOARD_slots +\n           LBOARD1 * LBOARD_slots + LBOARD2 * LBOARD_slots <= m;\n\n% Constraints based on available quantities\nconstraint sum([BOARD1, BOARD2, BOARD3]) <= sum(quantity_SINGLE) / BOARD_slots;\nconstraint sum([LBOARD1, LBOARD2]) <= sum(quantity_DOUBLE) / LBOARD_slots;\n\n% Objective: maximize the number of boards used\nvar int: total_boards = BOARD1 + BOARD2 + BOARD3 + LBOARD1 + LBOARD2;\nsolve maximize total_boards;\n\noutput ['Single slot boards: ', show(BOARD1), ', ', show(BOARD2), ', ', show(BOARD3), 'XXxn',\n        'Double slot boards: ', show(LBOARD1), ', ', show(LBOARD2), 'XXxn',\n        'Total boards used: ', show(total_boards), 'XXxn'];", "Classroom Scheduling Model": "% Parameters\nint: n;  % Total number of classrooms\nint: m;  % Maximum hours per classroom per day\nint: school_hours_per_day = 3;  % Total school hours per day\nint: days_in_week = 5;  % Total days in the week\nint: subjects = 4;  % Subjects (A, B, C, D)\nint: k;  % Total classes\nint: z;  % Maximum subjects per class\n\n% Sessions required by class for each subject over the week\narray[1..k, 1..subjects] of int: ClassSubjectQty;\n\n% Decision variables: class assigned to room at a given time\narray[1..k, 1..days_in_week, 1..school_hours_per_day] of var 1..n: schedule;\n\n% Constraints\nconstraint forall(d in 1..days_in_week, t in 1..school_hours_per_day) (\n    sum(c in 1..k)(schedule[c, d, t]) <= n\n);  % At most n classes at the same time on each day\n\nconstraint forall(c in 1..k, d in 1..days_in_week) (\n    sum(t in 1..school_hours_per_day)(schedule[c, d, t]) <= z\n);  % Each class has at most z subjects per day\n\nconstraint forall(c in 1..k, s in 1..subjects) (\n    sum(d in 1..days_in_week, t in 1..school_hours_per_day)(\n        schedule[c, d, t] * (if ClassSubjectQty[c, s] > 0 then 1 else 0 endif)\n    ) <= ClassSubjectQty[c, s]\n);  % Ensure the required sessions are met for each subject\n\nsolve satisfy;  % There is no specific optimization objective\n\n% Output\noutput [\n    'Schedule for Class ', show(c), ' on Day ', show(d), ':XXxn',\n    'XXxtA: ', sum(t in 1..school_hours_per_day)(if schedule[c, d, t] > 0 /XXx ClassSubjectQty[c, 1] > 0 then 1 else 0 endif), ' sessionsXXxn',\n    'XXxtB: ', sum(t in 1..school_hours_per_day)(if schedule[c, d, t] > 0 /XXx ClassSubjectQty[c, 2] > 0 then 1 else 0 endif), ' sessionsXXxn',\n    'XXxtC: ', sum(t in 1..school_hours_per_day)(if schedule[c, d, t] > 0 /XXx ClassSubjectQty[c, 3] > 0 then 1 else 0 endif), ' sessionsXXxn',\n    'XXxtD: ', sum(t in 1..school_hours_per_day)(if schedule[c, d, t] > 0 /XXx ClassSubjectQty[c, 4] > 0 then 1 else 0 endif), ' sessionsXXxn'\n    | c in 1..k, d in 1..days_in_week\n];", "Furniture Arrangement Compatibility": "int: rows; % from dzn\nint: cols; % from dzn\nint: n_furniture; % from dzn\n\narray[1..n_furniture, 1..n_furniture] of int: compatibility; % from dzn\n\n% Decision variables: position of each furniture piece\narray[1..n_furniture] of var 1..(rows*cols): position; \n\n% Ensure no two furniture pieces occupy the same position\nconstraint forall(i, j in 1..n_furniture where i != j) (\n    position[i] != position[j]\n);\n\n% Ensure adjacency based on compatibility matrix\nconstraint\n    forall(i, j in 1..n_furniture where i < j) (\n        % Same row or same column and not diagonally adjacent\n        (abs((position[i] - 1) div cols - (position[j] - 1) div cols) +\n         abs((position[i] - 1) mod cols - (position[j] - 1) mod cols) > 1) XXx/ compatibility[i, j] > 0\n    );\n\nsolve satisfy;\n\n% Output\noutput ['Result: XXxn'] ++ [\n    'Furniture ' ++ show(i) ++ ' at position ' ++ show(position[i]) ++ 'XXxn'\n    | i in 1..n_furniture\n];", "Seating and Pricing Optimization Problem": "int: availableSeats; % Total available seatsXXxnint: vipSeatsUsed; % Number of VIP seats usedXXxnint: freeSeatsUsed; % Number of regular (free) seats usedXXxnint: vipTicketPrice; % Price of VIP ticketsXXxnint: regularTicketPrice; % Price of regular ticketsXXxnint: totalExpenses; % Total expenses (including staff salary and concert fund)XXxnXXxn% ConstraintsXXxnconstraint vipSeatsUsed <= 200; % VIP seats usage constraintXXxnconstraint freeSeatsUsed <= 400; % Free seats usage constraintXXxnconstraint freeSeatsUsed >= 400; % Free seats for special guestsXXxnconstraint vipSeatsUsed + freeSeatsUsed <= availableSeats; % Total seats usage constraintXXxnXXxn% Total price requirementXXxnconstraint (vipSeatsUsed * vipTicketPrice + freeSeatsUsed * regularTicketPrice) >= 50000;XXxnXXxn% Profit calculationXXxnint: totalRevenue = vipSeatsUsed * vipTicketPrice + freeSeatsUsed * regularTicketPrice;XXxnint: profit = totalRevenue - totalExpenses;XXxnXXxn% Objective: Maximize profitXXxnsolve maximize profit;XXxnXXxn% OutputXXxnoutput [XXxn'VIP seats used: ', show(vipSeatsUsed), 'XXxn',XXxn'Free seats used: ', show(freeSeatsUsed), 'XXxn',XXxn'Total revenue: $', show(totalRevenue), 'XXxn',XXxn'Total expenses: $', show(totalExpenses), 'XXxn',XXxn'Profit: $', show(profit), 'XXxn'XXxn];", "Board Allocation Optimization": "int: BOARD1; % from dzn\r\nint: BOARD2; % from dzn\r\nint: LBOARD1; % from dzn\r\nint: LBOARD2; % from dzn\r\n\r\nint: TOTAL_SLOTS = 36;  % Total available slots\r\n\r\n% Slot occupation rules\r\nset of int: ODD_SLOTS = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};\r\nset of int: EVEN_SLOTS = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36};\r\nset of int: SPECIFIC_SLOTS_BOARD1 = {6, 12, 18, 24, 30, 36}; % Specific slots for BOARD1\r\nset of int: SPECIFIC_SLOTS_BOARD2 = {10, 20, 30}; % Specific slots for BOARD2\r\nset of int: POWERS_OF_2_SLOTS = {1, 2, 4, 8, 16, 32}; % Powers of 2\r\n\r\n% Decision variables: slots assigned to each board type\r\narray[1..TOTAL_SLOTS] of var bool: board1_slots;  % Slots for BOARD1\r\narray[1..TOTAL_SLOTS] of var bool: board2_slots;  % Slots for BOARD2\r\narray[1..TOTAL_SLOTS] of var bool: lboard1_slots; % Slots for LBOARD1\r\narray[1..TOTAL_SLOTS] of var bool: lboard2_slots; % Slots for LBOARD2\r\n\r\n% Constraint: BOARD1 can only occupy even slots, specific slots, and powers of 2\r\nconstraint forall(i in 1..TOTAL_SLOTS) (\r\n    board1_slots[i] -> (i in EVEN_SLOTS XXx/ i in SPECIFIC_SLOTS_BOARD1 XXx/ i in POWERS_OF_2_SLOTS)\r\n);\r\n\r\n% Constraint: BOARD2 can only occupy odd slots and specific slots\r\nconstraint forall(i in 1..TOTAL_SLOTS) (\r\n    board2_slots[i] -> (i in ODD_SLOTS XXx/ i in SPECIFIC_SLOTS_BOARD2)\r\n);\r\n\r\n% Constraint: LBOARD1 can occupy all slots\r\n% No additional constraints needed for LBOARD1\r\n% Constraint: LBOARD2 can only occupy odd and even slots according to its type (no restriction)\r\n% No additional constraints needed for LBOARD2\r\n\r\n% Constraint: Each slot can be occupied by at most one board type\r\nconstraint forall(i in 1..TOTAL_SLOTS) (\r\n    (board1_slots[i] XXx/ board2_slots[i] XXx/ lboard1_slots[i] XXx/ lboard2_slots[i]) <= 1\r\n);\r\n\r\n% Objective: Maximize the number of slots allocated\r\nvar int: total_allocated = sum(i in 1..TOTAL_SLOTS)(bool2int(board1_slots[i]) +\r\n                                                   bool2int(board2_slots[i]) +\r\n                                                   bool2int(lboard1_slots[i]) +\r\n                                                   bool2int(lboard2_slots[i]));\r\n\r\nsolve maximize total_allocated;\r\n\r\noutput ['Total Allocated: XXx(total_allocated)XXxn',\r\n        'BOARD1 Slots: XXx( [i | i in 1..TOTAL_SLOTS where board1_slots[i]] )XXxn',\r\n        'BOARD2 Slots: XXx( [i | i in 1..TOTAL_SLOTS where board2_slots[i]] )XXxn',\r\n        'LBOARD1 Slots: XXx( [i | i in 1..TOTAL_SLOTS where lboard1_slots[i]] )XXxn',\r\n        'LBOARD2 Slots: XXx( [i | i in 1..TOTAL_SLOTS where lboard2_slots[i]] )XXxn'];", "3D Spatial Placement with Constraints": "int: space1_length;  % Length of the first spaceXXxnint: space1_width;   % Width of the first spaceXXxnint: space1_height;  % Height of the first spaceXXxnint: space2_length;  % Length of the second spaceXXxnint: space2_width;   % Width of the second spaceXXxnint: space2_height;  % Height of the second spaceXXxnXXxn% Dimensions of the itemsXXxnint: item1_length;   % Length of item 1XXxnint: item1_width;    % Width of item 1XXxnint: item1_height;   % Height of item 1XXxnint: item2_length;   % Length of item 2XXxnint: item2_width;    % Width of item 2XXxnint: item2_height;   % Height of item 2XXxnint: item3_length;   % Length of item 3XXxnint: item3_width;    % Width of item 3XXxnint: item3_height;   % Height of item 3XXxnXXxn% Variables for the position of each item in the corresponding spaceXXxnarray[1..3] of var 0..space1_length: item1_pos;  % Position of item 1 in space 1XXxnarray[1..3] of var 0..space2_length: item2_pos;  % Position of item 2 in space 2XXxnarray[1..3] of var 0..space2_length: item3_pos;  % Position of item 3 in space 2XXxnXXxn% Constraints to ensure items do not intersect in their respective spacesXXxnconstraint item1_pos[1] + item1_length <= item2_pos[1] XXx/ item2_pos[1] + item2_length <= item1_pos[1];  % LengthXXxnconstraint item1_pos[2] + item1_width <= item2_pos[2] XXx/ item2_pos[2] + item2_width <= item1_pos[2];    % WidthXXxnconstraint item1_pos[3] + item1_height <= item2_pos[3] XXx/ item2_pos[3] + item2_height <= item1_pos[3];  % HeightXXxnXXxnconstraint item1_pos[1] + item1_length <= item3_pos[1] XXx/ item3_pos[1] + item3_length <= item1_pos[1];  % LengthXXxnconstraint item1_pos[2] + item1_width <= item3_pos[2] XXx/ item3_pos[2] + item3_width <= item1_pos[2];    % WidthXXxnconstraint item1_pos[3] + item1_height <= item3_pos[3] XXx/ item3_pos[3] + item3_height <= item1_pos[3];  % HeightXXxnXXxnconstraint item2_pos[1] + item2_length <= item3_pos[1] XXx/ item3_pos[1] + item3_length <= item2_pos[1];  % LengthXXxnconstraint item2_pos[2] + item2_width <= item3_pos[2] XXx/ item3_pos[2] + item3_width <= item2_pos[2];    % WidthXXxnconstraint item2_pos[3] + item2_height <= item3_pos[3] XXx/ item3_pos[3] + item3_height <= item2_pos[3];  % HeightXXxnXXxn% Constraints to ensure items respect the boundaries of the spacesXXxnconstraint item1_pos[1] + item1_length <= space1_length;  % LengthXXxnconstraint item1_pos[2] + item1_width <= space1_width;    % WidthXXxnconstraint item1_pos[3] + item1_height <= space1_height;  % HeightXXxnXXxnconstraint item2_pos[1] + item2_length <= space2_length;  % LengthXXxnconstraint item2_pos[2] + item2_width <= space2_width;    % WidthXXxnconstraint item2_pos[3] + item2_height <= space2_height;  % HeightXXxnXXxnconstraint item3_pos[1] + item3_length <= space2_length;  % LengthXXxnconstraint item3_pos[2] + item3_width <= space2_width;    % WidthXXxnconstraint item3_pos[3] + item3_height <= space2_height;  % HeightXXxnXXxnsolve satisfy;XXxnXXxnoutput [XXxn  'Item 1 Position: ', show(item1_pos), 'XXxn',XXxn  'Item 2 Position: ', show(item2_pos), 'XXxn',XXxn  'Item 3 Position: ', show(item3_pos), 'XXxn'XXxn];", "Budget-Constrained Electricity Generation Problem": "int: num_panels = 6; % Number of solar panelsXXxnint: cost_per_panel = 830; % Cost per solar panelXXxnint: electricity_per_panel = 800; % Electricity generated per panel in kWhXXxnfloat: cost_per_kWh = 0.5; % Cost of electricity per kWhXXxnint: total_budget = 5000; % Total budgetXXxnint: electricity_demand; % Total electricity demand in kWhXXxnXXxn% Calculate the total cost of solar panelsXXxnint: total_cost_solar_panels = num_panels * cost_per_panel;XXxnXXxn% Calculate the total electricity generated by solar panelsXXxnint: total_electricity_generated = num_panels * electricity_per_panel;XXxnXXxn% Calculate the remaining electricity demand after using solar panelsXXxnvar int: remaining_demand = electricity_demand - total_electricity_generated;XXxnXXxn% Calculate the total cost including additional electricity if neededXXxnvar float: cost_additional_electricity;XXxnconstraint remaining_demand >= 0 ->XXxn    cost_additional_electricity = remaining_demand * cost_per_kWh;XXxnconstraint remaining_demand < 0 ->XXxn    cost_additional_electricity = 0.0;XXxnXXxnvar float: total_cost = total_cost_solar_panels + cost_additional_electricity;XXxnXXxn% Check if the total cost is within the budgetXXxnconstraint total_cost <= total_budget;XXxnXXxnsolve satisfy;XXxnXXxnoutput ['Total cost of solar panels: ', show(total_cost_solar_panels), 'XXxn',XXxn        'Total electricity generated by solar panels: ', show(total_electricity_generated), ' kWhXXxn',XXxn        'Remaining electricity demand: ', show(remaining_demand), ' kWhXXxn',XXxn        'Cost of additional electricity: $', show(cost_additional_electricity), 'XXxn',XXxn        'Total cost: $', show(total_cost), 'XXxn',XXxn        'Is the total cost within budget? ', show(total_cost <= total_budget)];", "Furniture Arrangement with Compatibility Constraints": "int: num_furniture = 4;  % Number of furniture piecesXXxnint: room_size = 3;  % Room dimensions (3x3 grid)XXxnXXxn% Compatibility matrixXXxnarray[1..num_furniture, 1..num_furniture] of int: compatibility;XXxnXXxn% Positions of furniture pieces on the gridXXxnarray[1..num_furniture] of var 1..room_size: row;XXxnarray[1..num_furniture] of var 1..room_size: col;XXxnXXxn% Constraint 1: Unique PositionXXxnconstraint forall(i, j in 1..num_furniture where i < j) (XXxn    (row[i] != row[j]) XXx/ (col[i] != col[j])XXxn);XXxnXXxn% Constraint 2: CompatibilityXXxnconstraint forall(i, j in 1..num_furniture where i != j) (XXxn    if compatibility[i, j] == 0 thenXXxn        abs(row[i] - row[j]) + abs(col[i] - col[j]) > 1XXxn    elseif compatibility[i, j] == 2 thenXXxn        abs(row[i] - row[j]) + abs(col[i] - col[j]) == 1XXxn    elseXXxn        trueXXxn    endifXXxn);XXxnXXxn% Objective: Just find a valid arrangement (no optimization needed)XXxnsolve satisfy;XXxnXXxn% Output the positions of each furniture pieceXXxnoutput [XXxn    'Furniture positions:XXxn'XXxn] ++XXxn[XXxn    'Furniture ' ++ show(i) ++ ': (' ++ show(row[i]) ++ ', ' ++ show(col[i]) ++ ')XXxn'XXxn    | i in 1..num_furnitureXXxn];", "Optimization Problem": "int: total_seats = 1000;  % Total number of seats\r\nint: vip_seat_limit = 200;  % Maximum VIP seats\r\nint: free_seat_limit = 400;  % Maximum regular (free) seats\r\nint: special_guests_requirement = 400;  % Free seats needed for special guests\r\nint: vip_ticket_price = 170;  % Price of VIP ticket\r\nint: regular_ticket_price = 60;  % Price of regular ticket\r\nint: expense_per_vip = 100;  % Expense per VIP ticket sold\r\nint: expense_per_regular = 30;  % Expense per regular ticket sold\r\nint: total_revenue_goal = 50000;  % Revenue goal\r\n% Variables\r\nvar 0..vip_seat_limit: x;  % Number of VIP tickets sold\r\nvar 0..(total_seats - vip_seat_limit): y;  % Number of regular tickets sold\r\n% Constraints\r\nconstraint x + y <= total_seats;  % Total seats constraint\r\nconstraint x <= vip_seat_limit;  % VIP seats limit\r\nconstraint y <= free_seat_limit;  % Free seats limit (initially reserved for special guests)\r\nconstraint y >= special_guests_requirement;  % Ensure at least 400 free seats for special guests\r\nconstraint vip_ticket_price * x + regular_ticket_price * y >= total_revenue_goal;  % Total price requirement\r\n\r\n% Profit calculation\r\nvar int: total_revenue = vip_ticket_price * x + regular_ticket_price * y;\r\nvar int: total_expenses = expense_per_vip * x + expense_per_regular * y;\r\nvar int: profit = total_revenue - total_expenses;\r\n\r\n% Solve\r\nsolve maximize profit;\r\n\r\n% Output\r\noutput [ 'VIP tickets sold: ' ++ show(x) ++ 'XXxn' ++\r\n          'Regular tickets sold: ' ++ show(y) ++ 'XXxn' ++\r\n          'Total revenue: ' ++ show(total_revenue) ++ 'XXxn' ++\r\n          'Total expenses: ' ++ show(total_expenses) ++ 'XXxn' ++\r\n          'Profit: ' ++ show(profit) ];", "3D Spatial Packing Problem": "int: N = 10; % Dimension of the 3D space (10x10x10) XXxnXXxn% Item dimensions (length, width, height) XXxnarray[1..3] of int: item1; XXxnarray[1..3] of int: item2; XXxnarray[1..3] of int: item3; XXxnarray[1..3] of int: item4; XXxnarray[1..3] of int: item5; XXxnXXxn% Space dimensions XXxnint: space_length = 10; XXxnint: space_width = 10; XXxnint: space_height = 10; XXxnXXxn% Volume of the space XXxnint: space_volume = space_length * space_width * space_height; XXxnXXxn% Calculate the volume of each item XXxnint: volume_item1 = item1[1] * item1[2] * item1[3]; XXxnint: volume_item2 = item2[1] * item2[2] * item2[3]; XXxnint: volume_item3 = item3[1] * item3[2] * item3[3]; XXxnint: volume_item4 = item4[1] * item4[2] * item4[3]; XXxnint: volume_item5 = item5[1] * item5[2] * item5[3]; XXxnXXxn% Total volume of all items XXxnint: total_items_volume = volume_item1 + volume_item2 + volume_item3 + volume_item4 + volume_item5; XXxnXXxn% Constraint 1: Check if the total volume of items is less than or equal to the space volume XXxnconstraint total_items_volume <= space_volume; XXxnXXxn% Decision variable: 3D grid to represent the placement of items (0 = empty, 1 = occupied) XXxnarray[1..N, 1..N, 1..N] of var 0..1: grid; XXxnXXxn% Constraints for each item to be placed in the grid without intersectionXXxnconstraint XXxn    forall(i in 1..3, j in 1..3, k in 1..3) ( XXxn        item1[i] + item2[j] + item3[k] <= N -> XXxn        grid[item1[i], item2[j], item3[k]] = 0 XXxn    ); XXxnXXxnconstraint XXxn    forall(i in 1..3, j in 1..3, k in 1..3) ( XXxn        item4[i] + item5[j] + item1[k] <= N -> XXxn        grid[item4[i], item5[j], item1[k]] = 0 XXxn    ); XXxnXXxnconstraint XXxn    forall(i in 1..3, j in 1..3, k in 1..3) ( XXxn        item2[i] + item4[j] + item5[k] <= N -> XXxn        grid[item2[i], item4[j], item5[k]] = 0 XXxn    ); XXxnXXxnconstraint XXxn    forall(i in 1..3, j in 1..3, k in 1..3) ( XXxn        item3[i] + item1[j] + item2[k] <= N -> XXxn        grid[item3[i], item1[j], item2[k]] = 0 XXxn    ); XXxnXXxn% Ensure that the total number of occupied cells in the grid does not exceed the total volume of itemsXXxnconstraint sum(i in 1..N, j in 1..N, k in 1..N)(grid[i,j,k]) <= total_items_volume; XXxnXXxn% Objective: Check if all items can be placed in the gridXXxnsolve satisfy; XXxnXXxn% Output the resultXXxnoutput [XXxn    'Total volume of items: ', show(total_items_volume), 'XXxn',XXxn    'Space volume: ', show(space_volume), 'XXxn',XXxn    if total_items_volume <= space_volume thenXXxn        'All items can be placed in the space: Yes'XXxn    elseXXxn        'All items can be placed in the space: No'XXxn    endifXXxn];", "Budget Sufficiency Problem": "int: num_panels = 6; % Number of solar panels neededXXxnint: cost_per_panel = 830; % Cost per solar panel in dollarsXXxnint: budget = 5000; % Total budget in dollarsXXxnint: electricity_per_panel = 800; % Electricity generated per solar panel in kWhXXxnint: yearly_demand = 4000; % Yearly electricity demand in kWhXXxnfloat: cost_of_additional_electricity = 0.5; % Cost of additional electricity per kWhXXxnXXxn% Step 1: Calculate the total cost of purchasing the solar panelsXXxnint: total_cost_panels = num_panels * cost_per_panel;XXxnXXxn% Step 2: Calculate the total electricity generated by the solar panelsXXxnint: total_electricity_generated = num_panels * electricity_per_panel;XXxnXXxn% Step 3: Check if the electricity generated meets the demandXXxnvar bool: meets_demand = total_electricity_generated >= yearly_demand;XXxnXXxn% Step 4: If the generated electricity is not enough, calculate the shortfall and the cost of additional electricityXXxnvar float: additional_cost = if meets_demand then 0 else (yearly_demand - total_electricity_generated) * cost_of_additional_electricity endif;XXxnXXxn% Step 5: Check if the total cost (panels + additional electricity) is within the budgetXXxnvar bool: sufficient_budget = total_cost_panels + additional_cost <= budget;XXxnXXxn% Final resultXXxnoutput ['Total cost of panels: XXx(total_cost_panels)XXxnElectricity generated by panels: XXx(total_electricity_generated)XXxnMeets demand: XXx(meets_demand)XXxnAdditional cost: XXx(additional_cost)XXxnSufficient budget: XXx(sufficient_budget)XXxn'];", "Grid-Based Furniture Arrangement with Compatibility Constraints": "int: num_furniture = 4;  % number of furniture piecesXXxnint: grid_size = 3;  % grid size (3x3)XXxnXXxn% Compatibility matrixXXxnarray[1..num_furniture, 1..num_furniture] of int: compatibility;XXxnXXxn% Variables: grid[i, j] gives the furniture piece at cell (i, j)XXxnarray[1..grid_size, 1..grid_size] of var 0..num_furniture: grid;XXxnXXxn% Constraint 1: Unique PositionXXxn% Ensure that each furniture piece occupies a unique positionXXxnconstraintXXxn    forall(f1, f2 in 1..num_furniture where f1 < f2) (XXxn        count([grid[i, j] | i in 1..grid_size, j in 1..grid_size], f1) = 1 /XXxXXxn        count([grid[i, j] | i in 1..grid_size, j in 1..grid_size], f2) = 1XXxn    );XXxnXXxn% Constraint 2: CompatibilityXXxn% Ensure that incompatible furniture pieces are not adjacentXXxnconstraintXXxn    forall(i, j in 1..grid_size, f1, f2 in 1..num_furniture where f1 != f2 /XXx compatibility[f1, f2] = 0) (XXxn        (i > 1 /XXx grid[i-1, j] = f2) XXx/XXxn        (i < grid_size /XXx grid[i+1, j] = f2) XXx/XXxn        (j > 1 /XXx grid[i, j-1] = f2) XXx/XXxn        (j < grid_size /XXx grid[i, j+1] = f2)XXxn    );XXxnXXxnsolve satisfy;XXxnXXxn% Output the gridXXxnoutput [XXxn    'Grid:XXxn',XXxn    concat(['[ ' ++ concat([show(grid[i, j]) ++ ' ' | j in 1..grid_size]) ++ ']XXxn' | i in 1..grid_size])XXxn];", "Grid-Based Placement Problem with Compatibility Constraints": "int: n = 4; % Number of furniture piecesXXxnint: room_size = 3; % Room dimensions (3x3 grid)XXxnXXxn% Compatibility matrixXXxnarray[1..n, 1..n] of int: compatibility;XXxnXXxn% Positions of furniture pieces in the roomXXxnarray[1..n, 1..2] of var 1..room_size: positions;XXxnXXxn% Constraint 1: Unique position for each furniture pieceXXxnconstraintXXxn  forall(i, j in 1..n where i < j) (XXxn    positions[i, 1] != positions[j, 1] XXx/ positions[i, 2] != positions[j, 2]XXxn  );XXxnXXxn% Constraint 2: Compatibility based on the compatibility matrixXXxnconstraintXXxn  forall(i, j in 1..n where i != j) (XXxn    if compatibility[i, j] == 0 thenXXxn      abs(positions[i, 1] - positions[j, 1]) + abs(positions[i, 2] - positions[j, 2]) > 1XXxn    elseif compatibility[i, j] == 2 thenXXxn      abs(positions[i, 1] - positions[j, 1]) + abs(positions[i, 2] - positions[j, 2]) == 1XXxn    elseXXxn      trueXXxn    endifXXxn  );XXxnXXxn% Objective: No specific objective, just find a valid arrangementXXxnsolve satisfy;XXxnXXxn% Output the positions of each furniture pieceXXxnoutput [XXxn  'Furniture Positions:XXxXXxn',XXxn  '--------------------XXxXXxn'XXxn] ++XXxn[XXxn  'Furniture ' ++ show(i) ++ ': (' ++ show(positions[i, 1]) ++ ', ' ++ show(positions[i, 2]) ++ ')XXxXXxn'XXxn  | i in 1..nXXxn] ++XXxn[XXxn  '--------------------'XXxn];", "3D Bin Packing with Non-Touching Constraints": "int: num_items = 5; % Number of itemsXXxnint: space_dim = 10; % Dimension of the 3D space (10x10x10)XXxnXXxn% Item dimensionsXXxnarray[1..num_items, 1..3] of int: item_dims = array2d(1..num_items, 1..3, [3, 3, 3, 3, 3, 2, 4, 4, 4, 3, 3, 3, 2, 3, 2]);XXxnXXxn% Item positions in the 3D spaceXXxnarray[1..num_items, 1..3] of var 0..space_dim: positions;XXxnXXxn% Constraint to ensure items are within the bounds of the spaceXXxnconstraint forall(i in 1..num_items) (XXxn    forall(d in 1..3) (XXxn        positions[i, d] + item_dims[i, d] <= space_dimXXxn    )XXxn);XXxnXXxn% Ensure items do not overlapXXxnconstraint forall(i in 1..num_items, j in i+1..num_items) (XXxn    forall(d in 1..3) (XXxn        abs(positions[i, d] - positions[j, d]) >= item_dims[i, d] + item_dims[j, d]XXxn    )XXxn);XXxnXXxn% Non-touching constraintsXXxn% Item 1 cannot touch: Item 2, Item 3, Item 5XXxnconstraint forall(d in 1..3) (XXxn    abs(positions[1, d] - positions[2, d]) >= item_dims[1, d] + item_dims[2, d] + 1 /XXxXXxn    abs(positions[1, d] - positions[3, d]) >= item_dims[1, d] + item_dims[3, d] + 1 /XXxXXxn    abs(positions[1, d] - positions[5, d]) >= item_dims[1, d] + item_dims[5, d] + 1XXxn);XXxnXXxn% Item 2 cannot touch: Item 4, Item 5XXxnconstraint forall(d in 1..3) (XXxn    abs(positions[2, d] - positions[4, d]) >= item_dims[2, d] + item_dims[4, d] + 1 /XXxXXxn    abs(positions[2, d] - positions[5, d]) >= item_dims[2, d] + item_dims[5, d] + 1XXxn);XXxnXXxn% Item 3 cannot touch: Item 4, Item 5XXxnconstraint forall(d in 1..3) (XXxn    abs(positions[3, d] - positions[4, d]) >= item_dims[3, d] + item_dims[4, d] + 1 /XXxXXxn    abs(positions[3, d] - positions[5, d]) >= item_dims[3, d] + item_dims[5, d] + 1XXxn);XXxnXXxnsolve satisfy;XXxnXXxnoutput [XXxn    'Item ', show(i), ': Position = (', show(positions[i, 1]), ', ', show(positions[i, 2]), ', ', show(positions[i, 3]), ')XXxn'XXxn    | i in 1..num_itemsXXxn];", "3D Bin Packing with Fixed Planes": "include 'globals.mzn';  % Importing global constraints\r\n\r\n% Item dimensions\r\nint: item1_dim1 = 4; % from dzn\r\nint: item1_dim2 = 4; % from dzn\r\nint: item1_dim3 = 4; % from dzn\r\nint: item2_dim1 = 4; % from dzn\r\nint: item2_dim2 = 2; % from dzn\r\nint: item2_dim3 = 2; % from dzn\r\nint: item3_dim1 = 2; % from dzn\r\nint: item3_dim2 = 5; % from dzn\r\nint: item3_dim3 = 2; % from dzn\r\n\r\n% Space dimensions\r\nint: space_dim1 = 10; % from dzn\r\nint: space_dim2 = 10; % from dzn\r\nint: space_dim3 = 10; % from dzn\r\n\r\n% Non-intersecting planes\r\nint: plane1_x = 2; % from dzn (x=2 plane)\r\nint: plane2_y = 4; % from dzn (y=4 plane)\r\n\r\n% Variables to represent the position of each item in the 3D space\r\narray[1..3, 1..3] of var 0..space_dim1: item_positions; % item_positions[item][dimension]\r\n\r\n% Constraints to ensure items fit within the space dimensions\r\nconstraint\r\n    item_positions[1, 1] + item1_dim1 <= space_dim1 /XXx\r\n    item_positions[1, 2] + item1_dim2 <= space_dim2 /XXx\r\n    item_positions[1, 3] + item1_dim3 <= space_dim3 /XXx\r\n    item_positions[2, 1] + item2_dim1 <= space_dim1 /XXx\r\n    item_positions[2, 2] + item2_dim2 <= space_dim2 /XXx\r\n    item_positions[2, 3] + item2_dim3 <= space_dim3 /XXx\r\n    item_positions[3, 1] + item3_dim1 <= space_dim1 /XXx\r\n    item_positions[3, 2] + item3_dim2 <= space_dim2 /XXx\r\n    item_positions[3, 3] + item3_dim3 <= space_dim3;\r\n\r\n% Constraints to ensure items do not intersect with the planes\r\nconstraint\r\n    item_positions[1, 1] + item1_dim1 <= plane1_x /XXx\r\n    item_positions[2, 1] + item2_dim1 <= plane1_x /XXx\r\n    item_positions[3, 1] + item3_dim1 <= plane1_x /XXx\r\n    item_positions[1, 2] + item1_dim2 <= plane2_y /XXx\r\n    item_positions[2, 2] + item2_dim2 <= plane2_y /XXx\r\n    item_positions[3, 2] + item3_dim2 <= plane2_y;\r\n\r\n% Constraints to ensure items do not overlap with each other\r\nconstraint\r\n    % Item 1 and Item 2\r\n    (item_positions[1, 1] + item1_dim1 <= item_positions[2, 1] XXx/ item_positions[2, 1] + item2_dim1 <= item_positions[1, 1]) /XXx\r\n    (item_positions[1, 2] + item1_dim2 <= item_positions[2, 2] XXx/ item_positions[2, 2] + item2_dim2 <= item_positions[1, 2]) /XXx\r\n    (item_positions[1, 3] + item1_dim3 <= item_positions[2, 3] XXx/ item_positions[2, 3] + item2_dim3 <= item_positions[1, 3]) /XXx\r\n    % Item 1 and Item 3\r\n    (item_positions[1, 1] + item1_dim1 <= item_positions[3, 1] XXx/ item_positions[3, 1] + item3_dim1 <= item_positions[1, 1]) /XXx\r\n    (item_positions[1, 2] + item1_dim2 <= item_positions[3, 2] XXx/ item_positions[3, 2] + item3_dim2 <= item_positions[1, 2]) /XXx\r\n    (item_positions[1, 3] + item1_dim3 <= item_positions[3, 3] XXx/ item_positions[3, 3] + item3_dim3 <= item_positions[1, 3]) /XXx\r\n    % Item 2 and Item 3\r\n    (item_positions[2, 1] + item2_dim1 <= item_positions[3, 1] XXx/ item_positions[3, 1] + item3_dim1 <= item_positions[2, 1]) /XXx\r\n    (item_positions[2, 2] + item2_dim2 <= item_positions[3, 2] XXx/ item_positions[3, 2] + item3_dim2 <= item_positions[2, 2]) /XXx\r\n    (item_positions[2, 3] + item2_dim3 <= item_positions[3, 3] XXx/ item_positions[3, 3] + item3_dim3 <= item_positions[2, 3]);\r\n\r\n% Solve\r\nsolve satisfy;\r\n\r\n% Output\r\noutput [ 'Item 1 Position: ' ++ show(item_positions[1,1]) ++ ', ' ++ show(item_positions[1,2]) ++ ', ' ++ show(item_positions[1,3]) ++ 'XXxn' ++\r\n          'Item 2 Position: ' ++ show(item_positions[2,1]) ++ ', ' ++ show(item_positions[2,2]) ++ ', ' ++ show(item_positions[2,3]) ++ 'XXxn' ++\r\n          'Item 3 Position: ' ++ show(item_positions[3,1]) ++ ', ' ++ show(item_positions[3,2]) ++ ', ' ++ show(item_positions[3,3]);", "Crop Resource Allocation Problem": "int: land_limit; % from dznXXxnint: water_limit; % from dznXXxnint: manure_limit; % from dznXXxnint: seed_limit; % from dznXXxnint: wheat_weight; % from dznXXxnint: rice_weight; % from dznXXxnint: maize_weight; % from dznXXxnXXxn% Decision variables: area allocated to each cropXXxnvar 0..land_limit: wheat_area;XXxnvar 0..water_limit: rice_area;XXxnvar 0..land_limit: maize_area;XXxnXXxn% ConstraintsXXxnconstraint wheat_area + rice_area + maize_area <= land_limit;XXxnconstraint 3 * wheat_area + 2 * rice_area + 1 * maize_area <= water_limit;XXxnconstraint 2 * wheat_area + 1 * rice_area + 3 * maize_area <= manure_limit;XXxnconstraint 1 * wheat_area + 1 * rice_area + 2 * maize_area <= seed_limit;XXxnXXxn% Objective function: maximize total weight of cropsXXxnvar int: total_weight = wheat_weight * wheat_area + rice_weight * rice_area + maize_weight * maize_area;XXxnXXxnsolve maximize total_weight;XXxnXXxnoutput ['Wheat: ', show(wheat_area), 'XXxnRice: ', show(rice_area), 'XXxnMaize: ', show(maize_area), 'XXxnTotal Weight: ', show(total_weight)];", "Solar Energy Cost Optimization": "int: demand = 4000; % Yearly electricity demand in kWhXXxnint: budget = 6000; % Budget constraintXXxnfloat: solar_cost = 1.0; % Cost of solar panels per kWhXXxnfloat: bought_cost = 0.5; % Cost of purchased electricity per kWhXXxnXXxn% Decision variablesXXxnvar 0..4000: solar_generation; % kWh generated by solar panelsXXxnvar 0..4000: bought_energy; % kWh purchased from the gridXXxnXXxn% ConstraintsXXxnconstraint solar_generation + bought_energy == demand; % Meet the yearly demandXXxnconstraint solar_generation * solar_cost + bought_energy * bought_cost <= budget; % Stay within budgetXXxnXXxn% ObjectiveXXxnsolve satisfy;XXxnXXxnoutput ['Solar generation: ', show(solar_generation), 'XXxnBought energy: ', show(bought_energy)];", "Ticket Pricing and Allocation Optimization": "int: total_seats = 1000;  % Total number of seatsXXxnint: vip_seats = 200;     % Number of VIP seatsXXxnint: special_guest_seats = 400;  % Number of free seats for special guestsXXxnint: vip_ticket_price = 170;  % Price of a VIP ticketXXxnint: regular_ticket_price = 60;  % Price of a regular ticketXXxnint: price_goal = 50000;  % Total price goalXXxnXXxn% Decision variablesXXxnvar 0..vip_seats: vip_tickets_sold;  % Number of VIP tickets soldXXxnvar 0..(total_seats - vip_seats - special_guest_seats): regular_tickets_sold;  % Number of regular tickets soldXXxnXXxn% Calculating revenue and profitXXxnvar int: total_revenue = vip_tickets_sold * vip_ticket_price + regular_tickets_sold * regular_ticket_price;XXxnvar int: expenses = 30000;  % Fixed expensesXXxnvar int: profit = total_revenue - expenses;XXxnXXxn% ConstraintsXXxnconstraint vip_tickets_sold + regular_tickets_sold <= total_seats - special_guest_seats;  % Total seats constraintXXxnconstraint total_revenue >= price_goal;  % Price goal constraintXXxnXXxn% Objective: We don't need to optimize anything, just check if the constraints can be satisfiedXXxnsolve satisfy;XXxnXXxn% OutputXXxnoutput ['VIP Tickets Sold: ', show(vip_tickets_sold), 'XXxnRegular Tickets Sold: ', show(regular_tickets_sold), 'XXxnTotal Revenue: $', show(total_revenue), 'XXxnProfit: $', show(profit)];", "3D Packing with Geometric Constraints": "include 'globals.mzn'; \n\nint: width = 10; \nint: height = 10; \nint: depth = 10; \n\nint: A_width = 4; \nint: A_height = 4; \nint: A_depth = 4; \n\nint: B_width = 4; \nint: B_height = 2; \nint: B_depth = 2; \n\nint: C_width = 2; \nint: C_height = 5; \nint: C_depth = 2; \n\n% Space 1 coordinates \narray[1..3] of var 0..width: space1; \n% Space 2 coordinates \narray[1..3] of var 0..width: space2; \n\n% Constraint: No item can intersect with the geometric planes x=2 and y=4. \nconstraint (space1[1] + A_width <= 2 XXx/ space1[2] + A_height <= 4 XXx/ space1[1] + A_width >= 2 + 0 XXx/ space1[2] + A_height >= 4 + 0) \n/XXx (space2[1] + A_width <= 2 XXx/ space2[2] + A_height <= 4 XXx/ space2[1] + A_width >= 2 + 0 XXx/ space2[2] + A_height >= 4 + 0); \n\n% Constraints for Space 1 \nconstraint space1[1] + A_width <= width /XXx space1[2] + A_height <= height /XXx space1[3] + A_depth <= depth; \n\n% Constraints for Space 2 \nconstraint space2[1] + A_width <= width /XXx space2[2] + A_height <= height /XXx space2[3] + A_depth <= depth; \n\n% Objective: Maximize the use of space by placing both items A and B in the two spaces \nvar int: total_space_used = (space1[1] + A_width) * (space1[2] + A_height) * (space1[3] + A_depth) + (space2[1] + B_width) * (space2[2] + B_height) * (space2[3] + B_depth); \n\nsolve maximize total_space_used; \n\noutput ['Space 1 coordinates: XXx(space1)XXxnSpace 2 coordinates: XXx(space2)XXxnTotal space used: XXx(total_space_used)'];", "Resource Allocation and Crop Yield Optimization": "int: n; %number of crops, from dznXXxnint: m; %number of resources, from dznXXxnXXxn% Resource limitsXXxnarray[1..m] of int: resource_limits; % from dznXXxnXXxn% Manure requirement per cropXXxnarray[1..n] of int: manure_requirement; % from dznXXxnXXxn% Crop weight requirementsXXxnarray[1..n] of int: crop_weight_requirement; % from dznXXxnXXxn% Desired crop yieldsXXxnarray[1..n] of int: desired_yields; % from dznXXxnXXxn% Available resourcesXXxnarray[1..m] of int: available_resources; % from dznXXxnXXxn% Decision variables: amount of each crop to plantXXxnarray[1..n] of var 0..max(available_resources): x;XXxnXXxn% ConstraintsXXxnconstraintXXxn  forall(i in 1..m) (XXxn    sum(j in 1..n) (resource_limits[i] * x[j]) <= available_resources[i]XXxn  ) /XXxXXxn  forall(i in 1..n) (XXxn    x[i] * manure_requirement[i] >= desired_yields[i] * crop_weight_requirement[i]XXxn  );XXxnXXxn% Objective: maximize the sum of the planted cropsXXxnvar int: total_planted = sum(i in 1..n) (x[i]);XXxnXXxnsolve maximize total_planted;XXxnXXxnoutput [XXx'Total planted crops: XXx' ++ show(total_planted) ++ XXx'XXxXXxnXXx' ++XXxn       concat([XXx'Crop XXx' ++ show(i) ++ XXx': XXx' ++ show(x[i]) ++ XXx'XXxXXxnXXx' | i in 1..n])];", "Budgeted Solar Energy Solution": "include 'globals.mzn'; \n\nint: panel_cost = 830; \nint: electricity_per_panel = 800; \nint: required_panels = 6; \nfloat: electricity_purchase_cost = 0.5; \nint: yearly_demand = 4000; \n\n% Calculate total cost of solar panels\nint: total_panel_cost = panel_cost * required_panels; \n\n% Calculate total electricity generated by solar panels\nint: total_electricity_generated = electricity_per_panel * required_panels; \n\n% Calculate additional electricity needed\nint: additional_electricity_needed = max(0, yearly_demand - total_electricity_generated); \n\n% Calculate total cost of purchased electricity\nfloat: total_electricity_purchase_cost = electricity_purchase_cost * additional_electricity_needed; \n\n% Check if the total cost of panels and purchased electricity is within the budget\nconstraint total_panel_cost + total_electricity_purchase_cost <= budget; \n\n% Check if the total electricity generated and purchased meets the demand\nconstraint total_electricity_generated + additional_electricity_needed >= yearly_demand; \n\n% Set the budget (you can change this value)\nint: budget = 5000; \n\nsolve satisfy; \n\noutput [ 'Total cost of solar panels: ', show(total_panel_cost), 'XXxn', \n         'Total electricity generated by solar panels: ', show(total_electricity_generated), ' kWhXXxn', \n         'Additional electricity needed: ', show(additional_electricity_needed), ' kWhXXxn', \n         'Total cost of purchased electricity: $', show(total_electricity_purchase_cost), 'XXxn', \n         'Total cost (panels + purchase): $', show(total_panel_cost + total_electricity_purchase_cost), 'XXxn', \n         'Can we meet the demand? ', \n         if total_panel_cost + total_electricity_purchase_cost <= budget /XXx \n            total_electricity_generated + additional_electricity_needed >= yearly_demand then 'Yes' \n         else 'No' endif ];", "Concert Seating Optimization Problem": "int: total_seats; % Total available seatsXXxnint: vip_seats; % VIP seatsXXxnint: regular_seats; % Regular seatsXXxnint: free_seats; % Free seatsXXxnint: vip_ticket_price; % Price of VIP ticketXXxnint: regular_ticket_price; % Price of regular ticketXXxnint: free_ticket_price; % Price of free ticket (usually 0)XXxnint: staff_salary; % Total staff salaryXXxnint: concert_fund; % Total concert fundXXxnint: total_price_goal; % Total price goalXXxnint: required_free_seats_for_special_guests; % Required free seats for special guestsXXxnXXxn% Decision variablesXXxnvar 0..200: vip_seats_used; % VIP seats usedXXxnvar 0..400: free_seats_used; % Free seats usedXXxnvar 0..total_seats: regular_seats_used; % Regular seats usedXXxnXXxn% ConstraintsXXxnconstraint vip_seats_used + regular_seats_used + free_seats_used <= total_seats; % Total seats used should not exceed available seatsXXxnconstraint vip_seats_used <= vip_seats; % VIP seats used should not exceed available VIP seatsXXxnconstraint free_seats_used <= free_seats; % Free seats used should not exceed available free seatsXXxnconstraint free_seats_used >= required_free_seats_for_special_guests; % Ensure the required number of free seats for special guestsXXxnXXxn% Total revenue calculationXXxnvar int: total_revenue = vip_seats_used * vip_ticket_price + regular_seats_used * regular_ticket_price + free_seats_used * free_ticket_price;XXxnXXxn% Ensure the total price goal is metXXxnconstraint total_revenue >= total_price_goal;XXxnXXxn% Total expensesXXxnint: total_expenses = staff_salary + concert_fund;XXxnXXxn% Profit calculationXXxnvar int: total_profit = total_revenue - total_expenses;XXxnXXxn% Objective: We want to maximize the total profitXXxnsolve maximize total_profit;XXxnXXxn% OutputXXxnoutput [XXxn    'VIP seats used: ', show(vip_seats_used), 'XXxn',XXxn    'Regular seats used: ', show(regular_seats_used), 'XXxn',XXxn    'Free seats used: ', show(free_seats_used), 'XXxn',XXxn    'Total revenue: $', show(total_revenue), 'XXxn',XXxn    'Total expenses: $', show(total_expenses), 'XXxn',XXxn    'Total profit: $', show(total_profit), 'XXxn'XXxn];", "Agricultural Resource Optimization Problem": "int: area_available; % Total area available (400 sqm) % from dzn\r\nint: water_available; % Total water available (5000 liters) % from dzn\r\nint: manure_available; % Total manure available (4000 kg) % from dzn\r\nint: seeds_available; % Total seeds available (50 kg) % from dzn\r\n\r\nint: required_crop1; % Required kg for crop 1 (200 kg) % from dzn\r\nint: required_crop2; % Required kg for crop 2 (150 kg) % from dzn\r\nint: required_crop3; % Required kg for crop 3 (100 kg) % from dzn\r\n\r\n% Manure requirement per square meter\r\nint: manure_per_sqm = 20; % 20 kg of manure per sqm % from dzn\r\n\r\n% Decision variables\r\nvar 0..area_available: area_crop1; % Area allocated to crop 1\r\nvar 0..area_available: area_crop2; % Area allocated to crop 2\r\nvar 0..area_available: area_crop3; % Area allocated to crop 3\r\n\r\nvar 0..water_available: water_crop1; % Water used for crop 1\r\nvar 0..water_available: water_crop2; % Water used for crop 2\r\nvar 0..water_available: water_crop3; % Water used for crop 3\r\n\r\nvar 0..seeds_available: seeds_crop1; % Seeds used for crop 1\r\nvar 0..seeds_available: seeds_crop2; % Seeds used for crop 2\r\nvar 0..seeds_available: seeds_crop3; % Seeds used for crop 3\r\n\r\n% Constraints\r\nconstraint area_crop1 + area_crop2 + area_crop3 <= area_available; % Total area used\r\nconstraint water_crop1 + water_crop2 + water_crop3 <= water_available; % Total water used\r\nconstraint (area_crop1 + area_crop2 + area_crop3) * manure_per_sqm <= manure_available; % Total manure used\r\nconstraint seeds_crop1 + seeds_crop2 + seeds_crop3 <= seeds_available; % Total seeds used\r\n\r\n% Ensure required crop weights are met\r\nconstraint area_crop1 * 100 >= required_crop1; % Crop 1 yield\r\nconstraint area_crop2 * 75 >= required_crop2; % Crop 2 yield\r\nconstraint area_crop3 * 50 >= required_crop3; % Crop 3 yield\r\n\r\n% Objective: We can prioritize the crops that have the highest requirement first\r\nsolve satisfy;\r\n\r\noutput [ 'Area Crop 1: ' ++ show(area_crop1) ++ 'XXxn' ++\r\n         'Area Crop 2: ' ++ show(area_crop2) ++ 'XXxn' ++\r\n         'Area Crop 3: ' ++ show(area_crop3) ++ 'XXxn' ++\r\n         'Water Crop 1: ' ++ show(water_crop1) ++ 'XXxn' ++\r\n         'Water Crop 2: ' ++ show(water_crop2) ++ 'XXxn' ++\r\n         'Water Crop 3: ' ++ show(water_crop3) ++ 'XXxn' ++\r\n         'Seeds Crop 1: ' ++ show(seeds_crop1) ++ 'XXxn' ++\r\n         'Seeds Crop 2: ' ++ show(seeds_crop2) ++ 'XXxn' ++\r\n         'Seeds Crop 3: ' ++ show(seeds_crop3) ++ 'XXxn'];", "Furniture Arrangement Optimization": "int: n; % Number of furniture pieces (from dzn) int: width; % Room width (from dzn) int: height; % Room height (from dzn) array[1..n, 1..n] of int: compatibility; % Compatibility matrix (from dzn) % 0: not adjacent, 1: adjacent, 2: must be adjacent array[1..n] of var 1..width: x; array[1..n] of var 1..height: y; % Position of each furniture piece constraint all_different(x); % Unique x-coordinates constraint all_different(y); % Unique y-coordinates constraint forall(i, j in 1..n where i != j) ( if compatibility[i, j] == 2 then % Must be adjacent constraint (abs(x[i] - x[j]) + abs(y[i] - y[j])) == 1 else if compatibility[i, j] == 1 then % Can be adjacent constraint (abs(x[i] - x[j]) + abs(y[i] - y[j])) <= 2 else % Not adjacent constraint (abs(x[i] - x[j]) + abs(y[i] - y[j])) >= 3 endif endif ); % Ensure that if two pieces are not compatible (0), they are not adjacent. % An adjacency is defined as being next to each other either horizontally or vertically. % The formula checks that the Manhattan distance is at least 3. output [ 'Positions: ', show(x), show(y) ];", "Concert Seating Optimization": "int: total_seats = 1000;  % Total available seatsXXxnint: vip_seats = 200;  % VIP seats availableXXxnint: regular_seats = 800;  % Regular seats availableXXxnint: free_seats = 400;  % Free seats availableXXxnint: vip_ticket_price = 300;  % Price of VIP ticketXXxnint: regular_ticket_price = 100;  % Price of Regular ticketXXxnint: free_ticket_price = 0;  % Price of Free ticket (for special guests)XXxnint: staff_salary = 25000;  % Salary for staffXXxnint: concert_fund = 20000;  % Fund required for the concertXXxnint: total_price_goal = 50000;  % Total price goalXXxnint: required_free_seats_for_special_guests = 400;  % Required free seats for special guestsXXxnXXxn% Decision variablesXXxnvar 0..vip_seats: vip_tickets_sold;  % VIP tickets soldXXxnvar 0..regular_seats: regular_tickets_sold;  % Regular tickets soldXXxnvar 0..free_seats: free_tickets_sold;  % Free tickets sold (for special guests)XXxnXXxn% ConstraintsXXxnconstraint vip_tickets_sold <= 200;  % VIP seat limitXXxnconstraint free_tickets_sold == required_free_seats_for_special_guests;  % Seats needed for special guestsXXxnconstraint vip_tickets_sold + regular_tickets_sold + free_tickets_sold <= total_seats;  % Total seats usedXXxnXXxn% Calculate total revenue and profitXXxnvar int: total_revenue = vip_tickets_sold * vip_ticket_price + regular_tickets_sold * regular_ticket_price + free_tickets_sold * free_ticket_price;XXxnvar int: total_expenses = staff_salary + concert_fund;XXxnvar int: profit = total_revenue - total_expenses;XXxnXXxn% Ensure that the total price goal is metXXxnconstraint total_revenue >= total_price_goal;XXxnXXxn% Objective: Maximize profit while meeting the total price goalXXxnvar int: objective = profit;XXxnXXxnsolve maximize objective;XXxnXXxn% OutputXXxnoutput [XXxn  'VIP tickets sold: ', show(vip_tickets_sold), 'XXxn',XXxn  'Regular tickets sold: ', show(regular_tickets_sold), 'XXxn',XXxn  'Free tickets sold: ', show(free_tickets_sold), 'XXxn',XXxn  'Total Revenue: $', show(total_revenue), 'XXxn',XXxn  'Total Expenses: $', show(total_expenses), 'XXxn',XXxn  'Profit: $', show(profit), 'XXxn'XXxn];", "Board Allocation Feasibility": "int: slots = 36; % Number of available slotsXXxnint: b1_quantity; % from dznXXxnint: b2_quantity; % from dznXXxnint: b3_quantity; % from dznXXxnint: b4_quantity; % from dznXXxnint: b5_quantity; % from dznXXxnXXxn% Board type 1: 6 slotsXXxn% Board type 2: 5 slotsXXxn% Board type 3: 4 slotsXXxn% Board type 4: 3 slotsXXxn% Board type 5: 2 slotsXXxnXXxnint: b1_slots = 6;XXxnint: b2_slots = 5;XXxnint: b3_slots = 4;XXxnint: b4_slots = 3;XXxnint: b5_slots = 2;XXxnXXxn% A variable to store the total number of slots usedXXxnvar int: total_slots_used;XXxnXXxn% Constraint to calculate the total number of slots used based on the quantities and slots per boardXXxnconstraintXXxn    total_slots_used = b1_quantity * b1_slots +XXxn    b2_quantity * b2_slots +XXxn    b3_quantity * b3_slots +XXxn    b4_quantity * b4_slots +XXxn    b5_quantity * b5_slots;XXxnXXxn% Constraint to check if the total used slots do not exceed the available slotsXXxnconstraintXXxn    total_slots_used <= slots;XXxnXXxnsolve satisfy;XXxnXXxnoutput ['Total slots used: ', show(total_slots_used), 'XXxn'];", "Bin Packing with Constraints": "int: n; % Number of itemsXXxnarray[1..n] of int: sizes; % Sizes of the itemsXXxnint: bin_capacity; % Capacity of each binXXxnarray[1..n, 1..n] of bool: cannot_touch; % Matrix indicating which items cannot touch each otherXXxnXXxn% Decision variable: bin[i] is the bin number for item iXXxnarray[1..n] of var 1..n: bin;XXxnXXxn% Constraint: Each bin must not exceed its capacityXXxnconstraintXXxn  forall(b in 1..n) (XXxn    sum(i in 1..n where bin[i] = b) (sizes[i]) <= bin_capacityXXxn  );XXxnXXxn% Constraint: Items that cannot touch must not be placed in adjacent positions within the same binXXxnconstraintXXxn  forall(i in 1..n, j in i+1..n where bin[i] = bin[j]) (XXxn    cannot_touch[i, j] -> abs(position[i] - position[j]) > 1XXxn  );XXxnXXxn% Auxiliary array to keep track of item positions in binsXXxnarray[1..n] of var 1..n: position;XXxnXXxn% Objective: Minimize the number of bins usedXXxnvar int: bins_used = max([bin[i] | i in 1..n]);XXxnsolve minimize bins_used;XXxnXXxn% Output the bins for each itemXXxnoutput ['Bins: ' ++ show(bin) ++ 'XXxn' ++ 'Positions: ' ++ show(position)];", "Concert Ticket Optimization Problem": "int: total_seats; % from dznXXxnint: vip_seats; % from dznXXxnint: free_seats; % from dznXXxnint: total_price_goal; % from dznXXxnint: required_seats_special_guests; % from dznXXxnint: free_seats_special_guests; % from dznXXxnint: regular_ticket_price; % from dznXXxnint: vip_ticket_price; % from dznXXxnint: staff_salary; % from dznXXxnint: concert_fund; % from dznXXxnXXxn% Decision variablesXXxnvar 0..total_seats: regular_tickets; % Regular tickets soldXXxnvar 0..vip_seats: vip_tickets; % VIP tickets soldXXxnvar 0..free_seats: free_tickets_special_guests; % Free tickets for special guestsXXxnXXxn% ConstraintsXXxnconstraint regular_tickets + vip_tickets <= total_seats; % Total seats constraintXXxnconstraint vip_tickets <= vip_seats; % VIP seats constraintXXxnconstraint free_tickets_special_guests <= free_seats; % Free seats for special guests constraintXXxnconstraint required_seats_special_guests <= total_seats; % Required seats for special guests constraintXXxnXXxn% Calculate the total revenue and profitXXxnvar int: total_revenue = (regular_tickets * regular_ticket_price) + (vip_tickets * vip_ticket_price);XXxnvar int: total_expenses = staff_salary + concert_fund;XXxnvar int: profit = total_revenue - total_expenses;XXxnXXxn% Check if we can meet the total price goal and maximize profitXXxnconstraint total_revenue >= total_price_goal;XXxnXXxnsolve satisfy;XXxnXXxnoutput [XXxn    'Regular tickets sold: ', show(regular_tickets), 'XXxn',XXxn    'VIP tickets sold: ', show(vip_tickets), 'XXxn',XXxn    'Free tickets for special guests: ', show(free_tickets_special_guests), 'XXxn',XXxn    'Total revenue: ', show(total_revenue), 'XXxn',XXxn    'Total expenses: ', show(total_expenses), 'XXxn',XXxn    'Profit: ', show(profit), 'XXxn'XXxn];", "Bin Packing with Restrictions": "int: num_items; % Number of items % from dznXXxnarray[1..num_items] of int: item_sizes; % Sizes of the items % from dznXXxnint: num_bins; % Number of bins % from dznXXxnint: bin_capacity; % Capacity of each bin % from dznXXxnXXxn% Incompatibility matrixXXxnarray[1..num_items, 1..num_items] of bool: incompatible; % from dznXXxnXXxn% Decision variable: bin[i] is the bin assigned to item iXXxnarray[1..num_items] of var 1..num_bins: bin;XXxnXXxn% Constraint 1: The total size of items in each bin must not exceed bin capacityXXxnconstraintXXxn  forall(b in 1..num_bins) (XXxn    sum(i in 1..num_items where bin[i] = b) (item_sizes[i]) <= bin_capacityXXxn  );XXxnXXxn% Constraint 2: Incompatible items cannot be packed in the same binXXxnconstraintXXxn  forall(i in 1..num_items, j in i+1..num_items where incompatible[i, j]) (XXxn    bin[i] != bin[j]XXxn  );XXxnXXxnsolve satisfy;XXxnXXxnoutput [XXxn  'Bin assignments: ', show(bin), 'XXxn'XXxn];", "Precision Agriculture Resource Allocation Problem": "int: total_water; % Total water available in litersXXxnint: total_land; % Total land available in square metersXXxnint: total_manure; % Total manure available in kilogramsXXxnint: total_seeds; % Total seeds available in kilogramsXXxnXXxn% Crop type parametersXXxnint: carrots_yield; % Yield per square meter for carrots (kg)XXxnint: potatoes_yield; % Yield per square meter for potatoes (kg)XXxnint: tomatoes_yield; % Yield per square meter for tomatoes (kg)XXxnint: cucumbers_yield; % Yield per square meter for cucumbers (kg)XXxnXXxnfloat: carrots_water; % Water usage per square meter for carrots (liters)XXxnfloat: potatoes_water; % Water usage per square meter for potatoes (liters)XXxnfloat: tomatoes_water; % Water usage per square meter for tomatoes (liters)XXxnfloat: cucumbers_water; % Water usage per square meter for cucumbers (liters)XXxnXXxnfloat: carrots_seeds; % Seed requirement per square meter for carrots (kg)XXxnfloat: potatoes_seeds; % Seed requirement per square meter for potatoes (kg)XXxnfloat: tomatoes_seeds; % Seed requirement per square meter for tomatoes (kg)XXxnfloat: cucumbers_seeds; % Seed requirement per square meter for cucumbers (kg)XXxnXXxn% Required weightsXXxnint: required_carrots; % Required weight of carrots (kg)XXxnint: required_potatoes; % Required weight of potatoes (kg)XXxnint: required_tomatoes; % Required weight of tomatoes (kg)XXxnint: required_cucumbers; % Required weight of cucumbers (kg)XXxnXXxn% Decision variablesXXxnvar 0..total_land: carrots_land; % Land allocated for carrots (square meters)XXxnvar 0..total_land: potatoes_land; % Land allocated for potatoes (square meters)XXxnvar 0..total_land: tomatoes_land; % Land allocated for tomatoes (square meters)XXxnvar 0..total_land: cucumbers_land; % Land allocated for cucumbers (square meters)XXxnXXxn% ConstraintsXXxnconstraintXXxn    carrots_land + potatoes_land + tomatoes_land + cucumbers_land <= total_land /XXxXXxn    carrots_water * carrots_land + potatoes_water * potatoes_land + tomatoes_water * tomatoes_land + cucumbers_water * cucumbers_land <= total_water /XXxXXxn    carrots_seeds * carrots_land + potatoes_seeds * potatoes_land + tomatoes_seeds * tomatoes_land + cucumbers_seeds * cucumbers_land <= total_seeds /XXxXXxn    (carrots_land + potatoes_land + tomatoes_land + cucumbers_land) * 20 <= total_manure;XXxnXXxn% Required yieldsXXxnvar int: total_carrots = carrots_yield * carrots_land;XXxnvar int: total_potatoes = potatoes_yield * potatoes_land;XXxnvar int: total_tomatoes = tomatoes_yield * tomatoes_land;XXxnvar int: total_cucumbers = cucumbers_yield * cucumbers_land;XXxnXXxn% Objective: Ensure all required weights are metXXxnconstraintXXxn    total_carrots >= required_carrots /XXxXXxn    total_potatoes >= required_potatoes /XXxXXxn    total_tomatoes >= required_tomatoes /XXxXXxn    total_cucumbers >= required_cucumbers;XXxnXXxnsolve satisfy;XXxnXXxnoutput [XXxn    'Carrots: ', show(carrots_land), ' sqmXXxn',XXxn    'Potatoes: ', show(potatoes_land), ' sqmXXxn',XXxn    'Tomatoes: ', show(tomatoes_land), ' sqmXXxn',XXxn    'Cucumbers: ', show(cucumbers_land), ' sqmXXxn'XXxn];", "Home Electricity Management Problem": "int: yearly_demand; % Yearly electricity demand of the house (kWh) % from dznXXxnint: budget; % Budget for energy ($) % from dznXXxnint: panel_cost; % Cost per solar panel ($) % from dznXXxnint: electricity_per_panel; % Electricity generated per solar panel (kWh) % from dznXXxnfloat: purchased_electricity_price; % Price of purchased electricity per unit ($/kWh) % from dznXXxnXXxnvar 0..budget div panel_cost: num_panels; % Number of solar panels to purchaseXXxnvar float: purchased_electricity; % Amount of electricity to purchaseXXxnXXxn% ConstraintsXXxnconstraintXXxn    num_panels * panel_cost <= budget /XXxXXxn    purchased_electricity = max(0, yearly_demand - num_panels * electricity_per_panel) /XXxXXxn    purchased_electricity * purchased_electricity_price + num_panels * panel_cost <= budget;XXxnXXxn% ObjectiveXXxnvar bool: is_sufficient =XXxn    num_panels * electricity_per_panel + purchased_electricity >= yearly_demand;XXxnXXxnoutput [XXxn    'Number of solar panels: XXx(num_panels)XXxn',XXxn    'Electricity purchased (kWh): XXx(purchased_electricity)XXxn',XXxn    'Is the yearly demand satisfied? XXx(if is_sufficient then 'Yes' else 'No' endif)XXxn'XXxn];"}, "assign": "Return this text:\nstart = 25;\narr=[35, 35, 20, 20, 20];", "apples_product_greater_than_15000": "%% MiniZinc model\nvar int: marko;\nvar int: petra;\n\nconstraint marko in {2, 3, 7, 23};\nconstraint petra in {4, 5, 6, 11};\nconstraint marko > petra;\nconstraint marko * petra > 15000;\n\noutput ['Marko: XXx(marko), Petra: XXx(petra)'];", "apples_product": "int: marko_min = 2;\nint: marko_max = 23;\nset of int: marko_values = marko_min..marko_max;\n\nint: petra_min = 4;\nint: petra_max = 11;\nset of int: petra_values = petra_min..petra_max;\n\nvar int: marko_value;\nvar int: petra_value;\nvar int: result;\n\nconstraint marko_value in marko_values;\nconstraint petra_value in petra_values;\nconstraint marko_value > petra_value;\nconstraint marko_value * petra_value > 15000;\n\nsolve minimize result;\n\noutput [show(result)];", "apples_product_greater_than_15000_RFS": "marko_min = 2;\nmarko_max = 6;\npetra_min = 1;\npetra_max = 10;", "apples_product_RFS": "marko = 2;\npetra = 4;", "apple_product_greater_than_15000_RFS": "marko = [1, 2, 3, 4, 5, 6];\npetra = [1, 2, 3, 4, 5, 6];", "Scheduling Problem_RFS": "% Data for the MiniZinc model\n% Unassigned input parameters\n\nb = 5; % Number of apples\nk = 3; % Number of students that must receive at least one apple", "Linear Regression_RFS": null, "Traveling Salesman Problem_RFS": "total_seats = 1000;\nvip_seats = 200;\nfree_seats = 400;", "Classification_RFS": null, "Unspecified_RFS": null, "Concert Ticket Selling Problem_RFS": " 'Determine if it's possible to sell concert tickets to meet a total price goal of $50,000, accommodate 400 special guests, and maximize profit, given 1,000 seats, 200 VIP seats, and expenses of $45,000.'\n\n", "Revenue Optimization Problem_RFS": "\nThere are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $150, and the regular ticket price is $50. The required number of free seats for special guests is 400. The total price goal is $50,000. The total expenses, including staff salary and concert fund, are $35,000. The goal profit is calculated by subtracting expenses from the total price goal.\n\n", "Ticket Selling Problem_RFS": "\nThere are 1,000 total seats for a concert. There are 200 VIP seats, and 400 free seats for special guests. The VIP ticket price is $150, and the regular ticket price is $50. The required number of free seats for special guests is 400. The total price goal is $50,000. The total expenses, including staff salary and concert fund, are $35,000. Calculate if it is possible to sell tickets to meet the total price goal while accommodating special guests and maximizing profit.\n\n", "Concert Ticket Selling\u95ee\u9898\u3002_RFS": "\nThere are 1,000 total seats for a concert. There are 200 VIP seats, and 400 free seats for special guests. The VIP ticket price is $150, and the regular ticket price is $50. The required number of free seats for special guests is 400. The total price goal that needs to be met through ticket sales is $50,000. The total revenue from ticket sales should cover expenses, including staff salary and concert fund, which amount to $35,000. Calculate if it's possible to achieve a profit while meeting all constraints.\n\n", "Board Configuration Problem_RFS": "\nThere are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board.\n\nInput:\nThere are three single-slot boards: BOARD1, BOARD2, and BOARD3, and two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2 (2^0, 2^1, 2^2, 2^3, 2^4). The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5, and 6, respectively. LBOARDs (LBOARD1, LBOARD2) each have a quantity of 4. If an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have a range of 0, 2, 3, 4, and so on, while LBOARD2 can have a range of 0, 2, 4, and so on. There could be multiple types of LBOARD1 and LBOARD2, each with different quantities. There are 36 slots available in total.\n\n", "Concert Ticket Selling\u95ee\u9898_RFS": "\nThere are 1,000 total seats for a concert. There are 200 VIP seats. The price of a VIP ticket is $170, and the price of a regular ticket is $60. There are 400 free seats for special guests. The required number of free seats for special guests is 400. The total revenue is calculated from the sale of VIP and regular tickets. Total expenses, including staff salary and concert fund, are $45,000. The total price goal is $50,000. Calculate if it's possible to sell concert tickets to meet the total price goal while accommodating special guests and maximizing profit.\n\n", "Board Placement Problem_RFS": " There are three single-slot boards, BOARD1, BOARD2, and BOARD3, and two double-slot boards, LBOARD1 and LBOARD2. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy slots 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2 (2^0, 2^1, 2^2, 2^3, 2^4). The quantity of each BOARD type is 5, 5, and 6, respectively, for BOARD1, BOARD2, and BOARD3, and 4 for each LBOARD (LBOARD1 and LBOARD2). If an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have quantities of 0, 2, 3, 4, and so on, while LBOARD2 can have quantities of 0, 2, 4, and so on. There are a total of 36 slots available.\n\n", "Profit Maximization Problem_RFS": " 'Total seats: 1000; VIP seats: 200; Free seats for special guests: 400; VIP ticket price: $170; Regular ticket price: $60; Total price goal: $50,000; Total expenses: $45,000; Required free seats for special guests: 400'\n", "Seat Allocation Problem_RFS": " Determine if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. The total price goal is $50,000. Total expenses, including staff salary and concert fund, are $45,000. The required number of free seats for special guests is 400.\n\n", "Board Allocation Problem_RFS": " 'There are 36 available slots. Boards: BOARD1, BOARD2, BOARD3, LBOARD1, LBOARD2. Quantity of BOARD1, BOARD2, BOARD3 is 5, 5, 6 respectively. Quantity of LBOARD1, LBOARD2 is 4, 4 respectively. BOARD1 and LBOARD1 can only go to odd slots. BOARD3 can only go to even slots. Slots for BOARD2 are 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31. Slots for LBOARD2 are 2^0, 2^1, 2^2, 2^3, 2^4.'\n\n", "Class Scheduling Problem_RFS": " 'There are n classrooms available, each of which can be used for a maximum of m hours per day. The school operates for 3 hours each day, from 5 to 8. There are k classes, with each class occupying one classroom for an hour at a time. Each classroom corresponds to a specific subject. A class can have between 1 and z subjects per week, and the weekly schedule spans 5 days. The school houses four subjects across its classrooms: A, B, C, and D. The quantity of class sessions per subject across different days is outlined in the following matrix: Class/Subject Qty = [2, 2, 1, 3, 1, 4, 3, 4, 1, 2, 4, 5, 4, 2, 3, 6]. Each row in the matrix corresponds to a different class, and each column represents one of the four subjects (A, B, C, and D). The task is to allocate the time for each subject in each classroom to ensure every class has its required sessions, while respecting the maximum available classroom hours per day. Create a balanced schedule across all five days, ensuring that no class exceeds its designated time for any subject and that subjects are properly distributed across the classrooms.'\n\n", "Bin Packing Problem_RFS": " 'The dimensions of the bin are 10 x 10 x 10, and the dimensions of the items are  (4,4,4), (4,2,2), (2,5,2). Prohibited planes are (x=2), (y=4). Is it possible to place the items without them intersecting?'\n\n", "Fixed Orientation Bin Packing Problem_RFS": "\nThe dimensions of the bin are 10 x 10 x 10, and the dimensions of the items are (4,4,4), (4,2,2), (2,5,2).\nThe non-intersecting planes are (x=2), (y=4).\n\n", "Precision Agriculture Field Management Problem_RFS": "\nDetermine if it's possible to grow the required weight of vegetables and fruits using the available resources. There are 5000 liters of water, 400 sqm of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types. Crop 1 is a vegetable, and Crops 2 and 3 are fruits. Crop 1 has a yield of 2 kg/sqm, requires 10 liters/sqm of water, and 0.1 kg/sqm of seeds. Crop 2 has a yield of 3 kg/sqm, requires 15 liters/sqm of water, and 0.2 kg/sqm of seeds. Crop 3 has a yield of 4 kg/sqm, requires 20 liters/sqm of water, and 0.15 kg/sqm of seeds. For each square meter, 20 kg of manure is required. The required weights are 200 kg for Crop 1, 150 kg for Crop 2, and 100 kg for Crop 3.\n\n", "Energy Budget Optimization_RFS": "\nDetermine if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity. The available yearly budget for energy is $5,000. The cost of each solar panel is $830, with each panel generating 800 kWh annually. The required number of panels is 6. The cost of purchasing electricity is $0.5 per kWh. The yearly electricity demand is 4,000 kWh.\n\n", "Furniture Placement Problem_RFS": " Arrange 4 furniture pieces in a 3x3 room such that the compatibility constraints are satisfied. Each furniture piece is marked with a number from 1 to 4. The compatibility matrix includes values of 0, 1, and 2, where:\n- 0 indicates that the respective furniture pieces cannot be adjacent.\n- 1 indicates that the respective furniture pieces can or do not have to be adjacent.\n- 2 indicates that the respective furniture pieces must be adjacent.\nEnsure that no two pieces of furniture occupy the same position and that all compatibility constraints are fulfilled.\n\n", "Constraint Satisfaction Problem_RFS": " 'There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD. There are three single-slot boards: BOARD1, BOARD2, and BOARD3, along with two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2, specifically 2^0, 2^1, 2^2, 2^3, and 2^4. The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5 and 6 respectively. LBOARDs (LBOARD1 and LBOARD2) each come in a quantity of 4. Additionally, if an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have a range of 0, 2, 3, 4, and so on, while LBOARD2 follows a range of 0, 2, 4, and so forth. Multiple types of LBOARD1 and LBOARD2 may exist, each with distinct quantities. There are 36 available slots in total for all boards.' \n\n", "3D Bin Packing_RFS": "\nThe dimensions of the bin are 10 x 10 x 10, and the dimensions of the items are: (3,3,3), (3,3,2), (4,2,3), (3,3,3), (2,3,2).\n\n", "Profit maximization problem._RFS": "\nDetermine if it's possible to sell concert tickets to meet a total price goal of $50,000, given that there are 1,000 total seats. There are 200 VIP seats, and 400 free seats for special guests. The required number of free seats for special guests is 400. The VIP ticket price is $170, and the regular ticket price is $60. The total expenses, including staff salary and concert fund, are $45,000. Calculate if the desired profit can be achieved.\n\n", "Classroom Scheduling Problem_RFS": " 'Create a weekly schedule for the school that allocates time for each subject in each classroom, ensuring that all classes meet their required sessions. The school houses the following subjects across its four classrooms: A, B, C, and D. The quantity of class sessions per subject across different days is outlined in the matrix: Class/Subject Qty = [ 2  2  1  3,\n 1  4  3  4,\n 1  2  4  5,\n 4  2  3  6]. Each row corresponds to a class, and each column represents a subject. Two classes share a classroom in one day. Balance the schedule across all five days, ensuring that all classes fulfill their required sessions without exceeding the available classroom hours per day.'\n\n", "3D Bin Packing\u95ee\u9898\u3002_RFS": "\nThe dimensions of the bin are 10 x 10 x 10 units, and the dimensions of the items are:  (3,3,3), (3,3,2), (4,2,3), (3,3,3), (2,3,2).\n\n", "3D Bin Packing Problem_RFS": " 'Is it possible to place 5 items in three 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (3,3,3), (3,3,2), (4,2,3), (3,3,3), (2,3,2).' \n\n", "Board Scheduling Problem_RFS": "\nThere are n different types of boards and m available slots. Each board type comes in different quantities. A board is either 1 slot (BOARD) or 2 slots (LBOARD). Some boards can only occupy certain types of slots. Each BOARD type has a quantity of 5, 5, and 6, respectively. LBOARD types each have a quantity of 4, with a minimum quantity of 2 if LBOARD is present. LBOARD1 can have 0, 2, 3, 4, etc., while LBOARD2 can have 0, 2, 4, etc. There are 36 total slots.\n\n", "Three-Dimensional Bin Packing\u95ee\u9898_RFS": "\nThe dimensions of the bin are 10 x 10 x 10, and the dimensions of the items are: (4,4,4), (4,2,2), (2,5,2).\n\n", "Concert Ticket Selling problem_RFS": "\nThere are 1,000 total seats for a concert. There are 200 VIP seats, and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. The required number of free seats for special guests is 400. The total price goal is $50,000. The total expenses, including staff salary and concert fund, are $45,000. Calculate if it's possible to sell concert tickets to meet the total price goal while accommodating special guests and maximizing profit.\n\n", "Generic Optimization_RFS": null, "Combinatorial Optimization._RFS": " Determine the possible combinations of boards that can be allocated to the available slots.\n\n", "3D Packing Problem_RFS": " 'Determine if it's possible to place 5 items in three 3-dimensional spaces of dimensions 10x10x10 units without them intersecting.'\n\n", "Resource Allocation Problem._RFS": " Determine if it's possible to grow the required weight of vegetables and fruits using the available resources.\n\n", "Solar Panel Budget Optimization_RFS": " Determine if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity.\n\n", "Furniture Arrangement Problem_RFS": " 'Arrange 4 furniture pieces in a 3x3 room such that incompatible pieces are not placed adjacent to each other, given the compatibility matrix where 0 indicates incompatibility and 1 indicates compatibility.'\n\n", "Ticket Sales Optimization_RFS": " There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. Constraints include ensuring that the total number of seats used does not exceed the available seats, VIP seats used should not exceed 200, free seats used should not exceed 400, and the required number of free seats for special guests is 400. The total price goal is $50,000 through ticket sales.\n\n", "3D Packing Problem with Constraints_RFS": " Is it possible to place 3 items in two 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (4,4,4), (4,2,2), (2,5,2)? \n\n", "Agricultural Resource Allocation Problem_RFS": " 'Determine if it's possible to grow the required weights of vegetables and fruits using the available resources, given the constraints on water, land, manure, and seeds. The required weights are 200 kg for crop 1 (vegetable), 150 kg for crop 2 (fruit), and 100 kg for crop 3 (fruit). The available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds.'\n\n", "Solar Panel Cost-Benefit Analysis_RFS": " Determine if a house's yearly electricity demand can be satisfied using a combination of solar panels and purchased electricity given the available $5,000 budget.\n\n", "ticket_sales_revenue_RFS": " 'Ensure that the total number of seats used does not exceed the available seats. VIP seats used should not exceed 200, and free seats used should not exceed 400. The required number of free seats for special guests is 400. Total price goal of $50,000 must be met through ticket sales. The total revenue should cover expenses to achieve the desired profit.'\n", "BOARD1_LBOARD1_ODD_BOARD3_EVEN_BOARD2_LBOARD2_SPECIAL_RFS": null, "classroom_scheduling_subject_session_constraints_RFS": " 'There are n classrooms available, each of which can be used for a maximum of m hours per day. The school operates for 3 hours each day, from 5 to 8. There are k classes, with each class occupying one classroom for an hour at a time. Each classroom corresponds to a specific subject. A class can have between 1 and z subjects per week, and the weekly schedule spans 5 days. The school houses four subjects across its classrooms: A, B, C, and D. The quantity of class sessions per subject across different days is outlined in the following matrix: Class/Subject Qty = [2, 2, 1, 3, 1, 4, 3, 4, 1, 2, 4, 5, 4, 2, 3, 6]. Given that the school operates for a total of 15 hours per week (3 hours per day for 5 days), the task is to allocate the time for each subject in each classroom to ensure every class has its required sessions, while respecting the maximum available classroom hours per day. Create a balanced schedule across all five days, ensuring that no class exceeds its designated time for any subject and that subjects are properly distributed across the classrooms.'\n", "2D non-overlapping placement with non-touching constraints_RFS": " 'Place 5 items in three 3D spaces without intersecting'\n", "3D Packing Problem with Restricted Placement_RFS": " 'Place 3 items in two 3D spaces without intersection.'\n", "Precision_Ag_Field_Management_RFS": " \nThe available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types with the following details:\n- Crop 1 (Vegetable): Yield of 2 kg/sqm, requires 10 liters/sqm of water, and 0.1 kg/sqm of seeds.\n- Crop 2 (Fruit): Yield of 3 kg/sqm, requires 15 liters/sqm of water, and 0.2 kg/sqm of seeds.\n- Crop 3 (Fruit): Yield of 4 kg/sqm, requires 20 liters/sqm of water, and 0.15 kg/sqm of seeds.\nConstraints:\n1. Resource Limits: Ensure that the total area used does not exceed 500 sqm, total water used does not exceed 10,000 liters, total manure used does not exceed 10,000 kg, and total seeds used does not exceed 50 kg.\n2. Manure Requirement: For each square meter, 20 kg of manure is required.\n3. Crop Weight Requirement: Ensure that the produced crop weight meets or exceeds the required weights:\n   - Crop 1: 200 kg\n   - Crop 2: 150 kg\n   - Crop 3: 100 kg\n\n", "solar_panel_budget_detection_RFS": " 'Ensure the yearly electricity demand of a house can be satisfied within a given budget using a combination of solar panels and purchased electricity.'\n", "furniture_arrangement_compatibility_RFS": " '4 furniture pieces need to be arranged in a 3x3 room satisfying compatibility constraints'\n", "Event Seating and Revenue Optimization_RFS": " Determine if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. The required number of free seats for special guests is 400. The total price goal is $50,000. Total expenses, including staff salary and concert fund, are $45,000. The goal profit is calculated by subtracting expenses from the total price goal.\n\n", "Board Assignment Problem_RFS": " There are n=5 different types of boards and m=36 available slots. Each type of board comes in different quantities. There are three single-slot boards: BOARD1, BOARD2, BOARD3, and two double-slot boards: LBOARD1, LBOARD2. BOARD1 and LBOARD1 can only occupy odd slots, BOARD3 can only occupy even slots, BOARD2 can occupy slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and LBOARD2 can only occupy slots that are powers of 2 (specifically 2^0, 2^1, 2^2, 2^3, 2^4). The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5, 6, and LBOARD (LBOARD1, LBOARD2) is 4. If LBOARD exists, the minimum quantity is 2, and the allowed quantity range for LBOARD1 is 0, 2, 3, 4, ... for LBOARD2, it's 0, 2, 4, ....\n", "3D Packing with Constraints_RFS": " 'Is it possible to place 5 items in three 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (3,3,3), (3,3,2), (4,4,4), (3,3,3), (2,3,2). Also item 1 cannot be touching items: 2, 3, and 5, item 2 cannot be touching 1 and 3, item 3 cannot be touching 1, 2 and 4, item 4 cannot be touching 2 and 5, and 5 cannot be touching 1 and 4.'\n\n", "Precision Agriculture Field Management_RFS": " \nThe available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types with the following details:\n- Crop 1 (Vegetable): Yield of 2 kg/sqm, requires 10 liters/sqm of water, and 0.1 kg/sqm of seeds.\n- Crop 2 (Fruit): Yield of 3 kg/sqm, requires 15 liters/sqm of water, and 0.2 kg/sqm of seeds.\n- Crop 3 (Fruit): Yield of 4 kg/sqm, requires 20 liters/sqm of water, and 0.15 kg/sqm of seeds.\nConstraints:\n1. Resource Limits: Ensure that the total area used does not exceed 500 sqm, total water used does not exceed 10,000 liters, total manure used does not exceed 10,000 kg, and total seeds used does not exceed 50 kg.\n2. Manure Requirement: For each square meter, 20 kg of manure is required.\n3. Crop Weight Requirement: Ensure that the produced crop weight meets or exceeds the required weights:\n   - Crop 1: 200 kg\n   - Crop 2: 150 kg\n   - Crop 3: 100 kg\n\n", "Home Electricity Management Problem_RFS": " 'Determine if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity, given the available budget of $5,000. Required solar panels: 6. Yearly electricity demand: 4,000 kWh. Solar panel cost per unit: $830. Electricity purchased per unit: $0.5. Cost of required solar panels: 4,980. Remaining budget: 20.'\n\n", "Three-Dimensional Packing Problem_RFS": " 'Is it possible to place 5 items in three 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (3,3,3), (3,3,2), (4,4,4), (3,3,3), (2,3,2). Also item 1 cannot be touching items: 2, 3, and 5, item 2 cannot be touching 1 and 3, item 3 cannot be touching 1, 2 and 4, item 4 cannot be touching 2 and 5, and 5 cannot be touching 1 and 4.'\n\n", "3D Packing Problem._RFS": " Place 3 items with dimensions (4,4,4), (4,2,2), (2,5,2) in two 3D spaces of 10x10x10 without intersection, where (x=2) and (y=4) are prohibited.\n\n", "Grid Adjacency Constraint Satisfaction Problem_RFS": " 'Arrange 4 furniture pieces in a 3x3 room, considering the specified compatibility constraints.'\n\n", "Concert Ticket Sales Optimization_RFS": " 'Number of VIP and regular tickets to sell to meet total price goal while respecting seat constraints and maximizing profit. VIP price: $170, Regular price: $60. Total price goal: $50,000. Total seats: 1,000 (VIP: 200, free: 400). Special guest seats: 400.' \n\n", "Class Schedule Optimization_RFS": " The school houses four subjects across its classrooms: A, B, C, and D. Each classroom can be used for a maximum of m hours per day. The weekly schedule spans 5 days. Each class has its subjects. There are n classrooms. Each class has its required number of sessions for each subject. A class can have up to z subjects per week. There are k classes. Allocate the time for each subject in each classroom, ensuring no class exceeds its designated time for any subject, and subjects are properly distributed across the classrooms. \n\n", "3D Non-Touching Packing Problem_RFS": " 'Is it possible to place 5 items in three 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (3,3,3), (3,3,2), (4,4,4), (3,3,3), (2,3,2). Also item 1 cannot be touching items: 2, 3, and 5, item 2 cannot be touching 1 and 3, item 3 cannot be touching 1, 2 and 4, item 4 cannot be touching 2 and 5, and 5 cannot be touching 1 and 4.'\n\n", "3D Packing with Obstacles_RFS": " Place 3 items in two 3-dimensional spaces of dimensions 10x10x10 without intersecting, item dimensions: (4,4,4), (4,2,2), (2,5,2), avoid planes: (x=2), (y=4)\n\n", "Home Electricity Management_RFS": " The Home Electricity Management problem involves determining if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity. The available yearly budget for energy is $5,000.\nData:\n- Solar Panels:\n  - Cost per panel: $830\n  - Electricity generated per panel: 800 kWh\n  - Required number of panels: 6\n- Electricity Purchase:\n  - Cost per unit: $0.5 per kWh\n- Electricity Demand:\n  - Yearly demand: 4,000 kWh\n\n", "Concert Ticket Sales Problem_RFS": " Determine if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, with 200 VIP seats and 400 free seats for special guests. The required number of free seats for special guests is 400. The VIP ticket price is $170, and the regular ticket price is $60. The total price goal is $50,000, and total expenses, including staff salary and concert fund, are $45,000.\n\n", "Board Type Quantities Problem_RFS": " There are n different board types and m available slots. Each board type comes in distinct quantities, with some occupying one slot (BOARD) and others occupying two slots (LBOARD). Determine the number of each type of board.\n\n", "3D Item Packing Problem_RFS": " Place 5 items in three 3-dimensional spaces of width 10 units, height 10 units, and depth 10 units without intersections. Item dimensions: (3,3,3), (3,3,2), (4,2,3), (3,3,3), (2,3,2). \n\n", "Precision Agriculture Field Management\u95ee\u9898\u3002_RFS": " Determine if it's possible to grow the required weight of vegetables and fruits using the available resources, given the specific crop details and constraints.\n\n", "Resource Allocation Problem_RFS": " 'The Precision Agriculture Field Management problem involves determining if it's possible to grow the required weight of vegetables and fruits using the available resources.'\n\n", "Adjacent Furniture Pieces in a 3x3 Room_RFS": " 'Arrange 4 furniture pieces in a 3x3 room according to compatibility constraints, where each furniture piece is marked with a number from 1 to 4. The compatibility matrix contains values of 0, 1, and 2. A value of 0 indicates that the respective furniture pieces cannot be adjacent, a value of 1 indicates no specific adjacency constraint, and a value of 2 indicates that the respective furniture pieces must be adjacent. Ensure that no two furniture pieces occupy the same position.'\n\n", "Energy Budget Allocation Problem_RFS": " \n- Solar Panels:\n  - Cost per panel: $830\n  - Electricity generated per panel: 800 kWh\n  - Required number of panels: 6\n- Electricity Purchase:\n  - Cost per unit: $0.5 per kWh\n- Electricity Demand:\n  - Yearly demand: 4,000 kWh\n\n", "Precision_Agriculture_Field_Management_RFS": " The available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types: Crop 1 yields 2 kg/sqm, Crop 2 yields 3 kg/sqm, and Crop 3 yields 4 kg/sqm. Crop 1 requires 0.1 kg seeds/sqm, Crop 2 requires 0.2 kg seeds/sqm, and Crop 3 requires 0.15 kg seeds/sqm. Manure: For each square meter, 20 kg manure is required. Ensure 10,000 liters water, 500 sqm land, 10,000 kg manure, 50 kg seeds. The crop weight requirements are 200 kg, 150 kg, and 100 kg, respectively.\n\n", "Electricity Management Problem_RFS": " \n- Solar Panels:\n  - Cost per panel: $830\n  - Electricity generated per panel: 800 kWh\n  - Required number of panels: 6\n- Electricity Purchase:\n  - Cost per unit: $0.5 per kWh\n- Electricity Demand:\n  - Yearly demand: 4,000 kWh\n\n", "Furniture_Placement_Store_RFS": " \n- Number of Furniture Pieces: 4\n- Room Dimensions: 3x3 grid\n- Compatibility Matrix:\n  - [0, 1, 2, 0]\n  - [1, 0, 1, 0]\n  - [2, 1, 0, 2]\n  - [0, 0, 2, 0]\n\n", "3D Non-Intersecting Item Placement Problem_RFS": " Place 5 items in three 3-dimensional spaces of width 10 units, height 10 units, and depth 10 units without them intersecting. The dimensions of each item are (3,3,3), (3,3,2), (4,4,4), (3,3,3), (2,3,2).\n\n", "Board Allocation Model_RFS": null, "Classroom Scheduling Model_RFS": " ''\n", "Classroom Session Scheduling Problem_RFS": " Classes A, B, C, and D each have specific weekly session needs that must be scheduled across five days. The goal is to allocate the hours per day for each subject in each classroom so that every class meets its required weekly sessions without exceeding the daily classroom hour limits.\n\n", "3D_Packing_with_Constraints_RFS": " Place 5 items in three 3-dimensional spaces of 10x10x10 units without intersecting, given the item dimensions and adjacency constraints.\n\n", "3D Non-Intersecting Packing Problem_RFS": null, "Geometric Plane Constraint Problem_RFS": " Is it possible to place 3 items in two 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (4,4,4), (4,2,2), (2,5,2).\n\n", "Energy_Budget_Optimization_RFS": " \n- Solar Panels:\n  - Cost per panel: $830\n  - Electricity generated per panel: 800 kWh\n  - Required number of panels: 6\n- Electricity Purchase:\n  - Cost per unit: $0.5 per kWh\n- Electricity Demand:\n  - Yearly demand: 4,000 kWh\n\n", "Furniture Arrangement Compatibility_RFS": " The Furniture Placement in a Store problem involves arranging 4 furniture pieces in a 3x3 room such that the compatibility constraints are satisfied. Each furniture piece is marked with a number from 1 to 4. Two furniture pieces are considered adjacent in a 3x3 room if they are above, below, left, or right of one another. If they are diagonally positioned relative to each other, that is not considered adjacent.\n\n", "Board Quantity Distribution Problem_RFS": " There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD. There are three single-slot boards: BOARD1, BOARD2, and BOARD3, along with two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2, specifically 2^0, 2^1, 2^2, 2^3, and 2^4.\n\n", "Classroom Schedule Optimization_RFS": " 'There are n classrooms available, each of which can be used for a maximum of m hours per day. The school operates for 3 hours each day, from 5 to 8. There are k classes, with each class occupying one classroom for an hour at a time. Each classroom corresponds to a specific subject. A class can have between 1 and z subjects per week, and the weekly schedule spans 5 days. The school houses four subjects across its classrooms: A, B, C, and D. The quantity of class sessions per subject across different days is outlined in the following matrix: Class/Subject Qty = [2, 2, 1, 3, 1, 4, 3, 4, 1, 2, 4, 5, 4, 2, 3, 6] Each row in the matrix corresponds to a different class, and each column represents one of the four subjects (A, B, C, and D). The numbers indicate the quantity of sessions needed for each class in each subject over the week. Given that the school operates for a total of 15 hours per week (3 hours per day for 5 days), the task is to allocate the time for each subject in each classroom to ensure every class has its required sessions, while respecting the maximum available classroom hours per day. Create a balanced schedule across all five days, ensuring that no class exceeds its designated time for any subject and that subjects are properly distributed across the classrooms.' \n\n", "3D_Bin_Packing_Problem_RFS": " Place the following items in three 3-dimensional spaces of 10x10x10 units each without intersection: (3,3,3), (3,3,2), (4,2,3), (3,3,3), (2,3,2).\n\n", "3D_Non_Intersecting_Packing_RFS": null, "3D Non-Intersecting Packing_RFS": " Place 3 items in two 3D spaces with dimensions 10x10x10, with item dimensions (4,4,4), (4,2,2), (2,5,2). Avoid intersecting planes (x=2) and (y=4).\n\n", "Classroom_Scheduling_RFS": " 'Matrix of required class sessions per subject per week:\n[2, 2, 1, 3,\n 1, 4, 3, 4,\n 1, 2, 4, 5,\n 4, 2, 3, 6]'\n'Number of classrooms available: n'\n'Hours available per classroom per day: m'\n'Total operating hours per week: 15'\n'Number of classes: k'\n'Maximum number of subjects per class: z'\n'Number of subjects: 4'\n", "Concert Ticket Selling Model_RFS": " There are 1,000 total seats for a concert. There are 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. The goal is to meet a total price of $50,000. The total expenses, including staff salary and concert fund, are $45,000. The required number of free seats for special guests is 400. Calculate if it's possible to sell tickets to meet the total price goal and achieve the desired profit, while accommodating special guests.\n\n", "Concert Ticket Sales Model_RFS": " Determine if it's possible to sell concert tickets to meet a total price goal of $50,000 while maximizing profit. The VIP ticket price is $170, and the regular ticket price is $60. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. \n\n", "Concert Ticket Selling_RFS": " Determine if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. Ensure constraints are satisfied to achieve the desired profit while meeting the total price goal and accommodating special guests.\n\n", "classroom_scheduling_RFS": " \nCreate a balanced weekly schedule for a school with n classrooms, each available for m hours per day. There are k classes, each needing specific class sessions for subjects A, B, C, and D. The school operates for 3 hours a day from 5 to 8, and the schedule spans 5 days.\nClass/Subject Qty =\n[2, 2, 1, 3,\n 1, 4, 3, 4,\n 1, 2, 4, 5,\n 4, 2, 3, 6]\nEnsure each class meets its required subject sessions without exceeding daily classroom limits and distribute subjects across classrooms.\n", "3D Non-Intersecting Item Packing_RFS": " Is it possible to place 5 items in three 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (3,3,3), (3,3,2), (4,4,4), (3,3,3), (2,3,2). Also item 1 cannot be touching items: 2, 3, and 5, item 2 cannot be touching 1 and 3, item 3 cannot be touching 1, 2 and 4, item 4 cannot be touching 2 and 5, and 5 cannot be touching 1 and 4.\n\n", "Classroom Scheduling_RFS": null, "Home_Electricity_Management_RFS": " \n- Solar Panels:\n  - Cost per panel: $830\n  - Electricity generated per panel: 800 kWh\n  - Required number of panels: 6\n- Electricity Purchase:\n  - Cost per unit: $0.5 per kWh\n- Electricity Demand:\n  - Yearly demand: 4,000 kWh\n- Available budget: $5,000\n\n", "Concert_Profit_Optimization_RFS": " \nTotal seats: 1000\nVIP seats: 200\nFree seats for special guests: 400\nTotal price goal: $50,000\nVIP ticket price: $170\nRegular ticket price: $60\n\n", "Concert_Revenue_Optimization_RFS": " \nTotal seats: 1000\nVIP seats: 200\nFree seats for special guests: 400\nTotal price goal: $50,000\nVIP ticket price: $170\nRegular ticket price: $60\n\n", "Solar_Panel_Electricity_Constraint_RFS": " \n- Budget: $5,000\n- Solar Panel Cost: $830 each\n- Solar Panels required: 6\n- Electricity Purchase cost: $0.5 per kWh\n- Electricity demand: 4,000 kWh/year\n", "Solar_Panel_Electricity_Constraints_RFS": " \n- Budget: $5,000\n- Solar Panel Cost: $830 each\n- Solar Panels required: 6\n- Electricity Purchase cost: $0.5 per kWh\n- Electricity demand: 4,000 kWh/year\n", "ConcertTicketSalesProfit_RFS": " \nTotal seats: 1000\nVIP seats: 200\nFree seats for special guests: 400\nTotal price goal: $50,000\nVIP ticket price: $170\nRegular ticket price: $60\n\n", "Concert_Ticket_Sales_Optimization_RFS": " \nTotal seats: 1000\nVIP seats: 200\nFree seats for special guests: 400\nTotal price goal: $50,000\nVIP ticket price: $170\nRegular ticket price: $60\n\n", "ConcertTicketSelling_RFS": " There are 1,000 total seats for a concert. This includes 200 VIP seats and 400 free seats for special guests. The price for VIP tickets is $170, and regular tickets are $60. The goal is to achieve a total revenue of $50,000, considering that the total expenses are $45,000. There are 400 required free seats for special guests. Can we meet the total price goal while accommodating special guests and maximizing profit?\n\n", "ConcertProfitMaximization_RFS": " \nAvailable seats: VIP (200), regular (800), free for guests (400)\nTicket prices: VIP ($170), regular ($60)\nTotal expenses: $45,000\nTotal price goal: $50,000\n\n", "ClassroomScheduling_RFS": " ''\n", "false_RFS": null, "FurnitureArrangementCompatibility_RFS": " 'The Furniture Placement in a Store problem (second variation) involves arranging 4 furniture pieces in a 3x3 room such that the compatibility constraints are satisfied. Each furniture piece is marked with a number from 1 to 4.\nData:\n- Number of Furniture Pieces: 4\n- Room Dimensions: 3x3 grid\n- Compatibility Matrix:\n  - [0, 1, 2, 0]\n  - [1, 0, 1, 0]\n  - [2, 1, 0, 2]\n  - [0, 0, 2, 0]'\n\n", "Board_Allocation_Model_RFS": " There are three single-slot boards: BOARD1, BOARD2, BOARD3, and two double-slot boards: LBOARD1, LBOARD2. Each type of board has specific slot restrictions. BOARD1 and LBOARD1 can only occupy odd-numbered slots. BOARD3 can only occupy even-numbered slots. BOARD2 can occupy slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31. LBOARD2 can only occupy slots that are powers of 2 (2^0, 2^1, 2^2, 2^3, 2^4). The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5, 6, and for LBOARDs (LBOARD1, LBOARD2) is 4. If there are LBOARDs, the minimum quantity is 2. LBOARD1 can have quantities of 0, 2, 3, 4, and so on. LBOARD2 can have quantities of 0, 2, 4, and so on. There are 36 available slots in total.\n\n", "HomeElectricityManagement_RFS": " The Home Electricity Management problem involves determining if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity. The available yearly budget for energy is $5,000.\nData:\n- Solar Panels:\n  - Cost per panel: $830\n  - Electricity generated per panel: 800 kWh\n  - Required number of panels: 6\n- Electricity Purchase:\n  - Cost per unit: $0.5 per kWh\n- Electricity Demand:\n  - Yearly demand: 4,000 kWh\n\n", "Furniture Arrangement Model_RFS": null, "FurniturePlacementInStore_RFS": null, "Seating and Revenue Optimization Problem_RFS": " 'The Concert Ticket Selling problem involves determining if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit.'\n\n", "BoardSlotAllocationProblem_RFS": " 'There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD. The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5 and 6 respectively. LBOARDs (LBOARD1 and LBOARD2) each come in a quantity of 4. Additionally, if an LBOARD is present, it comes in a minimum quantity of 2. There are 36 available slots in total for all boards.'\n\n", "3D Spatial Packing Problem_RFS": " 'You need to determine if it is possible to place 5 items in three 3-dimensional spaces of size 10x10x10 units without them intersecting. The dimensions of each item are given as coordinates (width, height, depth), and certain items have restrictions on their placement with respect to others.' \n\n", "3D Packing with Non-Touching Constraints_RFS": " 'Is it possible to place 5 items in three 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting? The dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (3,3,3), (3,3,2), (4,4,4), (3,3,3), (2,3,2).'\n\n", "Furniture Arrangement Compatibility Problem_RFS": " 'The Furniture Placement in a Store problem involves arranging 4 furniture pieces in a 3x3 room such that the compatibility constraints are satisfied.'\n\n", "Concert Ticket Pricing Optimization_RFS": " 'The Concert Ticket Selling problem involves determining if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60.' \n\n", "Seating and Pricing Optimization Problem_RFS": " The Concert Ticket Selling problem involves determining if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. \n\n", "Board Allocation Optimization_RFS": " 'There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD.\\nThere are three single-slot boards: BOARD1, BOARD2, and BOARD3, along with two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2, specifically 2^0, 2^1, 2^2, 2^3, and 2^4.\\nThe quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5 and 6 respectively. LBOARDs (LBOARD1 and LBOARD2) each come in a quantity of 4. Additionally, if an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have a range of 0, 2, 3, 4, and so on, while LBOARD2 follows a range of 0, 2, 4, and so forth. Multiple types of LBOARD1 and LBOARD2 may exist, each with distinct quantities.\\nThere are 36 available slots in total for all boards.' \n\n", "3D Spatial Placement with Constraints_RFS": " 'Given two 3-dimensional spaces of dimensions 10x10x10 each, determine if it is possible to place three items with specific dimensions in these spaces without them intersecting, and ensuring that none of the items intersect with the planes x=2 and y=4.' \n\n", "Budget-Constrained Electricity Generation Problem_RFS": " 'Determine if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity within an available budget of $5,000. The house requires 4,000 kWh of electricity per year, and the solution must consider the costs of both solar panels and purchased electricity.' \n\n", "Furniture Arrangement with Compatibility Constraints_RFS": " 'The Furniture Placement in a Store problem (second variation) involves arranging 4 furniture pieces in a 3x3 room such that the compatibility constraints are satisfied. Each furniture piece is marked with a number from 1 to 4. Two furniture pieces are considered adjacent in a 3x3 room if they are above, below, left or right of one another. If they are diagonally positioned relative to each other, that is not considered adjacent.' \n\n", "Optimization Problem_RFS": " 'The Concert Ticket Selling problem involves determining if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. Constraints: 1. Seat Usage: Ensure that the total number of seats used does not exceed the available seats. VIP seats used should not exceed 200, and free seats used should not exceed 400. The required number of free seats for special guests is 400. 2. Total Price Requirement: Ensure that the total price goal of $50,000 is met through ticket sales. 3. Profit Calculation: The total revenue is calculated from the sale of VIP and regular tickets. Total expenses, including staff salary and concert fund, are $45,000. The goal profit is calculated by subtracting expenses from the total price goal. Objective: Satisfy all constraints to achieve the desired profit while meeting the total price goal and accommodating special guests. A valid solution ensures that the required number of special guest seats is available, the total price goal is met, and the profit is optimized.' \n\n", "Backtracking Allocation Problem_RFS": " 'There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD. There are three single-slot boards: BOARD1, BOARD2, and BOARD3, along with two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2, specifically 2^0, 2^1, 2^2, 2^3, and 2^4. The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5 and 6 respectively. LBOARDs (LBOARD1 and LBOARD2) each come in a quantity of 4. Additionally, if an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have a range of 0, 2, 3, 4, and so on, while LBOARD2 follows a range of 0, 2, 4, and so forth. Multiple types of LBOARD1 and LBOARD2 may exist, each with distinct quantities. There are 36 available slots in total for all boards.' \n\n", "3D Packing with Plane Constraints_RFS": " 'Is it possible to place 3 items in two 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (4,4,4), (4,2,2), (2,5,2). Also the geometric planes with which no items can intersect are (x=2) and (y=4).' \n\n", "Crop Allocation Optimization Problem_RFS": " 'The Precision Agriculture Field Management problem involves determining if it's possible to grow the required weight of vegetables and fruits using the available resources. The available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types with the following details: - Crop 1 (Vegetable): Yield of 2 kg/sqm, requires 10 liters/sqm of water, and 0.1 kg/sqm of seeds. - Crop 2 (Fruit): Yield of 3 kg/sqm, requires 15 liters/sqm of water, and 0.2 kg/sqm of seeds. - Crop 3 (Fruit): Yield of 4 kg/sqm, requires 20 liters/sqm of water, and 0.15 kg/sqm of seeds. Constraints: 1. Resource Limits: Ensure that the total area used does not exceed 500 sqm, total water used does not exceed 10,000 liters, total manure used does not exceed 10,000 kg, and total seeds used does not exceed 50 kg. 2. Manure Requirement: For each square meter, 20 kg of manure is required. 3. Crop Weight Requirement: Ensure that the produced crop weight meets or exceeds the required weights: - Crop 1: 200 kg - Crop 2: 150 kg - Crop 3: 100 kg Objective: No optimization is needed; the goal is to satisfy all constraints with the given resources. A valid solution ensures that the required crop weights are achieved using the available resources and meeting all constraints.' \n\n", "Budget Sufficiency Problem_RFS": " 'The Home Electricity Management problem involves determining if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity. The available yearly budget for energy is $5,000.' \n\n", "Grid-Based Furniture Arrangement with Compatibility Constraints_RFS": " 'The Furniture Placement in a Store problem involves arranging 4 furniture pieces in a 3x3 room such that incompatible pieces are not placed adjacent to each other. Each furniture piece is marked with a number from 1 to 4.' \n\n", "Grid-Based Placement Problem with Compatibility Constraints_RFS": " 'The Furniture Placement in a Store problem (second variation) involves arranging 4 furniture pieces in a 3x3 room such that the compatibility constraints are satisfied. Each furniture piece is marked with a number from 1 to 4. Two furniture pieces are considered adjacent in a 3x3 room if they are above, below, left or right of one another. If they are diagonally positioned relative to eachother, that is not considered adjacent.' \n\n", "N/A_RFS": " 'There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD. There are three single-slot boards: BOARD1, BOARD2, and BOARD3, along with two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2, specifically 2^0, 2^1, 2^2, 2^3, and 2^4. The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5 and 6 respectively. LBOARDs (LBOARD1 and LBOARD2) each come in a quantity of 4. Additionally, if an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have a range of 0, 2, 3, 4, and so on, while LBOARD2 follows a range of 0, 2, 4, and so forth. Multiple types of LBOARD1 and LBOARD2 may exist, each with distinct quantities. There are 36 available slots in total for all boards.'\n\n", "Classroom Scheduling Optimization_RFS": " 'There are n classrooms available, each of which can be used for a maximum of m hours per day. The school operates for 3 hours each day, from 5 to 8. There are k classes, with each class occupying one classroom for an hour at a time. Each classroom corresponds to a specific subject. A class can have between 1 and z subjects per week, and the weekly schedule spans 5 days. The school houses four subjects across its classrooms: A, B, C, and D. The quantity of class sessions per subject across different days is outlined in the following matrix: Class/Subject Qty = [2, 2, 1, 3, 1, 4, 3, 4, 1, 2, 4, 5, 4, 2, 3, 6] Each row in the matrix corresponds to a different class, and each column represents one of the four subjects (A, B, C, and D). The numbers indicate the quantity of sessions needed for each class in each subject over the week. Given that the school operates for a total of 15 hours per week (3 hours per day for 5 days), the task is to allocate the time for each subject in each classroom to ensure every class has its required sessions, while respecting the maximum available classroom hours per day. Create a balanced schedule across all five days, ensuring that no class exceeds its designated time for any subject and that subjects are properly distributed across the classrooms.'\n\n", "3D Bin Packing with Non-Touching Constraints_RFS": " 'Is it possible to place 5 items in three 3 dimensional spaces of width of 10 units, height of 10 units, and depth of 10 units, without them intersecting, and the dimensions of each item (given as a set of three coordinates (width, height, depth)) are: (3,3,3), (3,3,2), (4,4,4), (3,3,3), (2,3,2). Also item 1 cannot be touching items: 2, 3, and 5, item 2 cannot be touching 1 and 3, item 3 cannot be touching 1, 2 and 4, item 4 cannot be touching 2 and 5, and 5 cannot be touching 1 and 4.'\n\n", "3D Bin Packing with Fixed Planes_RFS": " 'Determine if it is possible to place 3 items in two 3-dimensional spaces of dimensions 10x10x10 units without them intersecting, given the dimensions of each item and the geometric planes with which no items can intersect.'\n\n", "Crop Resource Allocation Problem_RFS": " The Precision Agriculture Field Management problem involves determining if it's possible to grow the required weight of vegetables and fruits using the available resources. The available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types with the following details: - Crop 1 (Vegetable): Yield of 2 kg/sqm, requires 10 liters/sqm of water, and 0.1 kg/sqm of seeds. - Crop 2 (Fruit): Yield of 3 kg/sqm, requires 15 liters/sqm of water, and 0.2 kg/sqm of seeds. - Crop 3 (Fruit): Yield of 4 kg/sqm, requires 20 liters/sqm of water, and 0.15 kg/sqm of seeds. Constraints: 1. Resource Limits: Ensure that the total area used does not exceed 500 sqm, total water used does not exceed 10,000 liters, total manure used does not exceed 10,000 kg, and total seeds used does not exceed 50 kg. 2. Manure Requirement: For each square meter, 20 kg of manure is required. 3. Crop Weight Requirement: Ensure that the produced crop weight meets or exceeds the required weights: - Crop 1: 200 kg - Crop 2: 150 kg - Crop 3: 100 kg Objective: No optimization is needed; the goal is to satisfy all constraints with the given resources. A valid solution ensures that the required crop weights are achieved using the available resources and meeting all constraints.\n\n", "Solar Energy Cost Optimization_RFS": " 'Determine if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity within a budget of $5,000.'\n\n", "Ticket Pricing and Allocation Optimization_RFS": " The Concert Ticket Selling problem involves determining if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. \n\n", "Slot Occupancy Optimization Problem_RFS": " 'There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD. There are three single-slot boards: BOARD1, BOARD2, and BOARD3, along with two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2, specifically 2^0, 2^1, 2^2, 2^3, and 2^4. The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5 and 6 respectively. LBOARDs (LBOARD1 and LBOARD2) each come in a quantity of 4. Additionally, if an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have a range of 0, 2, 3, 4, and so on, while LBOARD2 follows a range of 0, 2, 4, and so forth. Multiple types of LBOARD1 and LBOARD2 may exist, each with distinct quantities. There are 36 available slots in total for all boards.'\n\n", "3D Packing with Geometric Constraints_RFS": " 'Determine if it's possible to place 3 items in two 3-dimensional spaces of dimensions 10x10x10 units without intersecting, considering specific geometric plane restrictions and the dimensions of each item.' \n\n", "Resource Allocation and Crop Yield Optimization_RFS": " The Precision Agriculture Field Management problem involves determining if it's possible to grow the required weight of vegetables and fruits using the available resources. The available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types with the following details: - Crop 1 (Vegetable): Yield of 2 kg/sqm, requires 10 liters/sqm of water, and 0.1 kg/sqm of seeds. - Crop 2 (Fruit): Yield of 3 kg/sqm, requires 15 liters/sqm of water, and 0.2 kg/sqm of seeds. - Crop 3 (Fruit): Yield of 4 kg/sqm, requires 20 liters/sqm of water, and 0.15 kg/sqm of seeds. Constraints: 1. Resource Limits: Ensure that the total area used does not exceed 500 sqm, total water used does not exceed 10,000 liters, total manure used does not exceed 10,000 kg, and total seeds used does not exceed 50 kg. 2. Manure Requirement: For each square meter, 20 kg of manure is required. 3. Crop Weight Requirement: Ensure that the produced crop weight meets or exceeds the required weights: - Crop 1: 200 kg - Crop 2: 150 kg - Crop 3: 100 kg Objective: No optimization is needed; the goal is to satisfy all constraints with the given resources. A valid solution ensures that the required crop weights are achieved using the available resources and meeting all constraints.\n\n", "Budgeted Solar Energy Solution_RFS": " The Home Electricity Management problem involves determining if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity within a budget of $5,000.\n\n", "Concert Seating Optimization Problem_RFS": " 'The Concert Ticket Selling problem involves determining if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit. There are 1,000 total seats, including 200 VIP seats and 400 free seats for special guests. The VIP ticket price is $170, and the regular ticket price is $60. Ensure that the total number of seats used does not exceed the available seats. VIP seats used should not exceed 200, and free seats used should not exceed 400. The required number of free seats for special guests is 400. Ensure that the total price goal of $50,000 is met through ticket sales. The total revenue is calculated from the sale of VIP and regular tickets. Total expenses, including staff salary and concert fund, are $45,000. The goal profit is calculated by subtracting expenses from the total price goal. Satisfy all constraints to achieve the desired profit while meeting the total price goal and accommodating special guests. A valid solution ensures that the required number of special guest seats is available, the total price goal is met, and the profit is optimized.'\n\n", "Spatial Arrangement and Intersection Problem_RFS": " 'Determine if it's possible to place 3 items in two 3-dimensional spaces of dimensions 10x10x10 without them intersecting, considering specific geometric plane restrictions and the dimensions of each item.' \n\n", "Agricultural Resource Optimization Problem_RFS": " 'The Precision Agriculture Field Management problem involves determining if it's possible to grow the required weight of vegetables and fruits using the available resources. The available resources include 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. There are 3 crop types with the following details: - Crop 1 (Vegetable): Yield of 2 kg/sqm, requires 10 liters/sqm of water, and 0.1 kg/sqm of seeds. - Crop 2 (Fruit): Yield of 3 kg/sqm, requires 15 liters/sqm of water, and 0.2 kg/sqm of seeds. - Crop 3 (Fruit): Yield of 4 kg/sqm, requires 20 liters/sqm of water, and 0.15 kg/sqm of seeds. Constraints: 1. Resource Limits: Ensure that the total area used does not exceed 500 sqm, total water used does not exceed 10,000 liters, total manure used does not exceed 10,000 kg, and total seeds used does not exceed 50 kg. 2. Manure Requirement: For each square meter, 20 kg of manure is required. 3. Crop Weight Requirement: Ensure that the produced crop weight meets or exceeds the required weights: - Crop 1: 200 kg - Crop 2: 150 kg - Crop 3: 100 kg Objective: No optimization is needed; the goal is to satisfy all constraints with the given resources. A valid solution ensures that the required crop weights are achieved using the available resources and meeting all constraints.'\n\n", "Solar Panel Optimization Problem_RFS": " 'The Home Electricity Management problem involves determining if the yearly electricity demand of a house can be satisfied using a combination of solar panels and purchased electricity within a budget of $5,000.'\n\n", "Furniture Arrangement Optimization_RFS": " 'The Furniture Placement in a Store problem (second variation) involves arranging 4 furniture pieces in a 3x3 room such that the compatibility constraints are satisfied. Each furniture piece is marked with a number from 1 to 4. Ensure that no two pieces of furniture occupy the same position and that compatibility constraints are respected.'\n\n", "Concert Seating Optimization_RFS": " 'The Concert Ticket Selling problem involves determining if it's possible to sell concert tickets to meet a total price goal while accommodating special guests and maximizing profit.'\n\n", "Board Allocation Feasibility_RFS": " 'There are n different types of boards and m available slots for them to be allocated. Each board type comes in distinct quantities. Each board takes 1 or 2 slots per board. Boards that occupy one slot are referred to as BOARD, and those that occupy two slots are referred to as LBOARD. There are three single-slot boards: BOARD1, BOARD2, and BOARD3, along with two double-slot boards: LBOARD1 and LBOARD2. Each type of board has unique restrictions on the slots it can occupy. BOARD1 and LBOARD1 can only occupy odd-numbered slots, while BOARD3 can only occupy even-numbered slots. BOARD2 can occupy the following slots: 1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. LBOARD2 can only occupy slots that are powers of 2, specifically 2^0, 2^1, 2^2, 2^3, and 2^4. The quantity of each BOARD type (BOARD1, BOARD2, BOARD3) is 5, 5 and 6 respectively. LBOARDs (LBOARD1 and LBOARD2) each come in a quantity of 4. Additionally, if an LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 can have a range of 0, 2, 3, 4, and so on, while LBOARD2 follows a range of 0, 2, 4, and so forth. Multiple types of LBOARD1 and LBOARD2 may exist, each with distinct quantities. There are 36 available slots in total for all boards.'\n\n", "Slot Allocation Problem_RFS": " 'There are 36 available slots. There are 5 BOARD1, 5 BOARD2, 6 BOARD3, 4 LBOARD1 and 4 LBOARD2. BOARD1, LBOARD1 can occupy only odd slots. BOARD3 can only occupy even slots. BOARD2 can occupy 1,2,3,5,7,11,13,17,19,23,29,31. LBOARD2 can occupy 2^0, 2^1, 2^2, 2^3, 2^4. If LBOARD is present, it comes in a minimum quantity of 2. LBOARD1 range 0,2,3,4, ... LBOARD2 range 0,2,4,... There are 3 types of single slot boards (BOARD1, BOARD2, BOARD3), and 2 types of double slot boards (LBOARD1, LBOARD2). Quantity of BOARD is BOARD1 5, BOARD2 5, BOARD3 6. Quantity of LBOARD 1 4, LBOARD 2 4.'\n\n", "Bin Packing with Constraints_RFS": " 'The dimensions of the bin are 10 x 10 x 10, and the dimensions of the items are: (3,3,3), (3,3,2),(4,4,4), (3,3,3), (2,3,2). Item 1 cannot be touching 2,3,5, item 2 cannot be touching 1,3, item 3 cannot be touching 1,2,4, item 4 cannot be touching 2,5.'\n\n", "Concert Ticket Optimization Problem_RFS": " 'Determine if it's possible to sell concert tickets to meet a total price goal of $50,000 while accommodating 400 special guests, 200 of whom are VIPs, and maximizing profit given the costs.'\n\n", "Bin Packing with Restrictions_RFS": " 'The dimensions of the bin are 10 x 10 x 10, and the dimensions of the items are: (3,3,3), (3,3,2), (4,2,3), (3,3,3), (2,3,2). Is it possible to pack all the items without them intersecting?'\n\n", "Precision Agriculture Resource Allocation Problem_RFS": " 'Determine if it's possible to grow the required weight of vegetables and fruits using the available resources: 5000 liters of water, 400 square meters of land, 4000 kg of manure, and 50 kg of seeds. Crop 1 (vegetable) has a yield of 2 kg/sqm and requires 10 liters/sqm of water and 0.1 kg/sqm of seeds. Crop 2 (fruit) has a yield of 3 kg/sqm and requires 15 liters/sqm and 0.2 kg/sqm. Crop 3 (fruit) has a yield of 4 kg/sqm and requires 20 liters/sqm and 0.15 kg/sqm. Required crop weights are 200 kg for Crop 1, 150 kg for Crop 2, and 100 kg for Crop 3.'\n\n"}